[1mdiff --git a/.hypothesis/unicode_data/14.0.0/charmap.json.gz b/.hypothesis/unicode_data/14.0.0/charmap.json.gz[m
[1mnew file mode 100644[m
[1mindex 00000000..09ab36a1[m
Binary files /dev/null and b/.hypothesis/unicode_data/14.0.0/charmap.json.gz differ
[1mdiff --git a/README.rst b/README.rst[m
[1mindex 404d4d52..44395c50 100644[m
[1m--- a/README.rst[m
[1m+++ b/README.rst[m
[36m@@ -6,261 +6,33 @@[m
 |AppVeyorBuild| |PyPiVersion| |PyPiLicense|[m
 |Python3| |GithubCommits| |BlackFormatBadge|[m
 [m
[31m-Pygame_ is a free and open-source cross-platform library[m
[31m-for the development of multimedia applications like video games using Python.[m
[31m-It uses the `Simple DirectMedia Layer library`_ and several other[m
[31m-popular libraries to abstract the most common functions, making writing[m
[31m-these programs a more intuitive task.[m
[32m+[m[32m# üéÆ Projet Tuteur√© - Contribution Pygame[m
[32m+[m[32mCe projet est r√©alis√© dans le cadre de la Licence Professionnelle ADSILLH.[m
 [m
[31m-`We need your help`_ to make pygame the best it can be![m
[31m-New contributors are welcome.[m
[32m+[m[32m## Membres du groupe[m
[32m+[m[32m- Junior NGANAMODEI[m
[32m+[m[32m- Tresor[m
[32m+[m[32m- Kalid[m
[32m+[m[32m- Samse[m
 [m
[32m+[m[32m## Objectif[m
[32m+[m[32mContribuer au projet open source **Pygame** en explorant le code source, en ajoutant des exemples de jeux, et en am√©liorant la documentation.[m
 [m
[31m-Installation[m
[31m-------------[m
[32m+[m[32m## ‚öôÔ∏è Installation[m
[32m+[m[32m```bash[m
[32m+[m[32mgit clone git@github.com:NGANAMODEIJunior/pygame-contrib-projet-tuteure.git[m
 [m
[31m-Before installing pygame, you must check that Python is installed[m
[31m-on your machine. To find out, open a command prompt (if you have[m
[31m-Windows) or a terminal (if you have MacOS or Linux) and type this:[m
[31m-::[m
[32m+[m[32mcd pygame-contrib-projet-tuteure[m
 [m
[31m-   python --version[m
[32m+[m[32mpython3 -m venv venv[m
 [m
[32m+[m[32msource venv/bin/activate[m
 [m
[31m-If a message such as "Python 3.8.10" appears, it means that Python[m
[31m-is correctly installed. If an error message appears, it means that[m
[31m-it is not installed yet. You must then go to the `official website[m
[31m-<https://www.python.org/downloads/>`_ to download it.[m
[32m+[m[32mpip install -r requirements.txt[m
 [m
[31m-Once Python is installed, you have to perform a final check: you have[m
[31m-to see if pip is installed. Generally, pip is pre-installed with[m
[31m-Python but we are never sure. Same as for Python, type the following[m
[31m-command:[m
[31m-::[m
[32m+[m[32mpython examples/test_quelette.py[m
 [m
[31m-   pip --version[m
 [m
[32m+[m[32m## Lien vers le projet original[m
[32m+[m[32mhttps://github.com/pygame/pygame[m
 [m
[31m-If a message such as "pip 20.0.2 from /usr/lib/python3/dist-packages/pip[m
[31m-(python 3.8)" appears, you are ready to install pygame! To install[m
[31m-it, enter this command:[m
[31m-::[m
[31m-[m
[31m-   pip install pygame[m
[31m-[m
[31m-Once pygame is installed, quickly test your library by entering the following[m
[31m-command, which opens one of the many example games that comes pre-installed: [m
[31m-::[m
[31m-[m
[31m-	python3 -m pygame.examples.aliens[m
[31m-[m
[31m-[m
[31m-If this doesn‚Äôt work, the `Getting Started [m
[31m-<https://www.pygame.org/wiki/GettingStarted/>`_ section of the official [m
[31m-website has more information for platform specific issues, such as adding[m
[31m-python to your machine‚Äôs PATH settings[m
[31m-[m
[31m-[m
[31m-Help[m
[31m-----[m
[31m-[m
[31m-If you are just getting started with pygame, you should be able to[m
[31m-get started fairly quickly.  Pygame comes with many tutorials and[m
[31m-introductions.  There is also full reference documentation for the[m
[31m-entire library. Browse the documentation on the `docs page`_. You[m
[31m-can also browse the documentation locally by running[m
[31m-``python -m pygame.docs`` in your terminal. If the docs aren't found[m
[31m-locally, it'll launch the online website instead.[m
[31m-[m
[31m-The online documentation stays up to date with the development version[m
[31m-of pygame on GitHub.  This may be a bit newer than the version of pygame[m
[31m-you are using. To upgrade to the latest full release, run[m
[31m-``pip install pygame --upgrade`` in your terminal.[m
[31m-[m
[31m-Best of all, the examples directory has many playable small programs[m
[31m-which can get you started playing with the code right away.[m
[31m-[m
[31m-[m
[31m-Features[m
[31m-----------[m
[31m-[m
[31m-Pygame is a powerful library for game development, offering a wide[m
[31m-range of features to simplify your coding journey. Let's delve into[m
[31m-what pygame has to offer:[m
[31m-[m
[31m-Graphics - With pygame, creating dynamic and engaging graphics has[m
[31m-never been easier. The library provides simple yet effective tools for[m
[31m-2D graphics and animation, including support for images, rectangles,[m
[31m-and polygon shapes. Whether you're a seasoned game developer or just[m
[31m-starting out, pygame has you covered.[m
[31m-[m
[31m-Sound - Pygame also includes support for playing and manipulating sound[m
[31m-and music, making it easy to add sound effects and background music to[m
[31m-your games. With support for WAV, MP3, and OGG file formats, you have[m
[31m-plenty of options to choose from.[m
[31m-[m
[31m-Input - Pygame provides intuitive functions for handling keyboard, mouse,[m
[31m-and joystick input, allowing you to quickly and easily implement player[m
[31m-controls in your games. No more struggling with complex input code, pygame[m
[31m-makes it simple.[m
[31m-[m
[31m-Game Development - Lastly, pygame provides a comprehensive suite of tools[m
[31m-and features specifically designed for game development. From collision[m
[31m-detection to sprite management, pygame has everything you need to create[m
[31m-exciting and engaging games. Whether you're building a platformer, puzzle[m
[31m-game, or anything in between, pygame has you covered.[m
[31m-[m
[31m-[m
[31m-Building From Source[m
[31m---------------------[m
[31m-[m
[31m-If you want to use features that are currently in development,[m
[31m-or you want to contribute to pygame, you will need to build pygame[m
[31m-locally from its source code, rather than pip installing it.[m
[31m-[m
[31m-Installing from source is fairly automated. The most work will[m
[31m-involve compiling and installing all the pygame dependencies.  Once[m
[31m-that is done, run the ``setup.py`` script which will attempt to[m
[31m-auto-configure, build, and install pygame.[m
[31m-[m
[31m-Much more information about installing and compiling is available[m
[31m-on the `Compilation wiki page`_.[m
[31m-[m
[31m-Contribute[m
[31m-----------[m
[31m-[m
[31m-* `Documentation Contributions <https://github.com/pygame/pygame/tree/main/docs>`_ - Guidelines for contributing to the main documentations[m
[31m-* `Writing your first unit test <http://renesd.blogspot.com/2019/11/draft-2-of-lets-write-unit-test.html>`_ - Step by step guide on how to write your first unit test in Python for Pygame.[m
[31m-* `How to Hack Pygame <https://www.pygame.org/wiki/Hacking>`_ - Information on hacking, developing, and modifying Pygame[m
[31m-* `Issue Tracker for beginners <https://github.com/pygame/pygame/labels/good%20first%20issue>`_ - A way for beginners to contribute to the project[m
[31m-* `Bugs & Patches <https://www.pygame.org/wiki/patchesandbugs>`_ - Report bugs[m
[31m-* `Communication tools <https://www.pygame.org/wiki/info>`_ - More information and ways to get in touch with the Pygame team[m
[31m-[m
[31m-[m
[31m-Credits[m
[31m--------[m
[31m-[m
[31m-Thanks to everyone who has helped contribute to this library.[m
[31m-Special thanks are also in order.[m
[31m-[m
[31m-* Marcus Von Appen: many changes, and fixes, 1.7.1+ freebsd maintainer[m
[31m-* Lenard Lindstrom: the 1.8+ windows maintainer, many changes, and fixes[m
[31m-* Brian Fisher for svn auto builder, bug tracker and many contributions[m
[31m-* Rene Dudfield: many changes, and fixes, 1.7+ release manager/maintainer[m
[31m-* Phil Hassey for his work on the pygame.org website[m
[31m-* DR0ID for his work on the sprite module[m
[31m-* Richard Goedeken for his smoothscale function[m
[31m-* Ulf Ekstr√∂m for his pixel perfect collision detection code[m
[31m-* Pete Shinners: original author[m
[31m-* David Clark for filling the right-hand-man position[m
[31m-* Ed Boraas and Francis Irving: Debian packages[m
[31m-* Maxim Sobolev: FreeBSD packaging[m
[31m-* Bob Ippolito: MacOS and OS X porting (much work!)[m
[31m-* Jan Ekhol, Ray Kelm, and Peter Nicolai: putting up with early design ideas[m
[31m-* Nat Pryce for starting our unit tests[m
[31m-* Dan Richter for documentation work[m
[31m-* TheCorruptor for his incredible logos and graphics[m
[31m-* Nicholas Dudfield: many test improvements[m
[31m-* Alex Folkner for pygame-ctypes[m
[31m-[m
[31m-Thanks to those sending in patches and fixes: Niki Spahiev, Gordon[m
[31m-Tyler, Nathaniel Pryce, Dave Wallace, John Popplewell, Michael Urman,[m
[31m-Andrew Straw, Michael Hudson, Ole Martin Bjoerndalen, Herve Cauwelier,[m
[31m-James Mazer, Lalo Martins, Timothy Stranex, Chad Lester, Matthias[m
[31m-Spiller, Bo Jangeborg, Dmitry Borisov, Campbell Barton, Diego Essaya,[m
[31m-Eyal Lotem, Regis Desgroppes, Emmanuel Hainry, Randy Kaelber[m
[31m-Matthew L Daniel, Nirav Patel, Forrest Voight, Charlie Nolan,[m
[31m-Frankie Robertson, John Krukoff, Lorenz Quack, Nick Irvine,[m
[31m-Michael George, Saul Spatz, Thomas Ibbotson, Tom Rothamel, Evan Kroske,[m
[31m-Cambell Barton.[m
[31m-[m
[31m-And our bug hunters above and beyond: Angus, Guillaume Proux, Frank[m
[31m-Raiser, Austin Henry, Kaweh Kazemi, Arturo Aldama, Mike Mulcheck,[m
[31m-Michael Benfield, David Lau[m
[31m-[m
[31m-There's many more folks out there who've submitted helpful ideas, kept[m
[31m-this project going, and basically made our life easier.  Thanks![m
[31m-[m
[31m-Many thank you's for people making documentation comments, and adding to the[m
[31m-pygame.org wiki.[m
[31m-[m
[31m-Also many thanks for people creating games and putting them on the[m
[31m-pygame.org website for others to learn from and enjoy.[m
[31m-[m
[31m-Lots of thanks to James Paige for hosting the pygame bugzilla.[m
[31m-[m
[31m-Also a big thanks to Roger Dingledine and the crew at SEUL.ORG for our[m
[31m-excellent hosting.[m
[31m-[m
[31m-Dependencies[m
[31m-------------[m
[31m-[m
[31m-Pygame is obviously strongly dependent on SDL and Python.  It also[m
[31m-links to and embeds several other smaller libraries.  The font[m
[31m-module relies on SDL_ttf, which is dependent on freetype.  The mixer[m
[31m-(and mixer.music) modules depend on SDL_mixer.  The image module[m
[31m-depends on SDL_image, which also can use libjpeg and libpng.  The[m
[31m-transform module has an embedded version of SDL_rotozoom for its[m
[31m-own rotozoom function.  The surfarray module requires the Python[m
[31m-NumPy package for its multidimensional numeric arrays.[m
[31m-Dependency versions:[m
[31m-[m
[31m-[m
[31m-+----------+------------------------+[m
[31m-| CPython  | >= 3.6 (Or use PyPy3)  |[m
[31m-+----------+------------------------+[m
[31m-| SDL      | >= 2.0.8               |[m
[31m-+----------+------------------------+[m
[31m-| SDL_mixer| >= 2.0.0               |[m
[31m-+----------+------------------------+[m
[31m-| SDL_image| >= 2.0.2               |[m
[31m-+----------+------------------------+[m
[31m-| SDL_ttf  | >= 2.0.11              |[m
[31m-+----------+------------------------+[m
[31m-| SDL_gfx  | (Optional, vendored in)|[m
[31m-+----------+------------------------+[m
[31m-| NumPy    | >= 1.6.2 (Optional)    |[m
[31m-+----------+------------------------+[m
[31m-[m
[31m-[m
[31m-[m
[31m-License[m
[31m--------[m
[31m-[m
[31m-This library is distributed under `GNU LGPL version 2.1`_, which can[m
[31m-be found in the file ``docs/LGPL.txt``.  We reserve the right to place[m
[31m-future versions of this library under a different license.[m
[31m-[m
[31m-This basically means you can use pygame in any project you want,[m
[31m-but if you make any changes or additions to pygame itself, those[m
[31m-must be released with a compatible license (preferably submitted[m
[31m-back to the pygame project).  Closed source and commercial games are fine.[m
[31m-[m
[31m-The programs in the ``examples`` subdirectory are in the public domain.[m
[31m-[m
[31m-See docs/licenses for licenses of dependencies.[m
[31m-[m
[31m-[m
[31m-.. |AppVeyorBuild| image:: https://ci.appveyor.com/api/projects/status/x4074ybuobsh4myx?svg=true[m
[31m-   :target: https://ci.appveyor.com/project/pygame/pygame[m
[31m-[m
[31m-.. |PyPiVersion| image:: https://img.shields.io/pypi/v/pygame.svg?v=1[m
[31m-   :target: https://pypi.python.org/pypi/pygame[m
[31m-[m
[31m-.. |PyPiLicense| image:: https://img.shields.io/pypi/l/pygame.svg?v=1[m
[31m-   :target: https://pypi.python.org/pypi/pygame[m
[31m-[m
[31m-.. |Python3| image:: https://img.shields.io/badge/python-3-blue.svg?v=1[m
[31m-[m
[31m-.. |GithubCommits| image:: https://img.shields.io/github/commits-since/pygame/pygame/2.1.2.svg[m
[31m-   :target: https://github.com/pygame/pygame/compare/2.1.2...main[m
[31m-[m
[31m-.. |BlackFormatBadge| image:: https://img.shields.io/badge/code%20style-black-000000.svg[m
[31m-    :target: https://github.com/psf/black[m
[31m-[m
[31m-.. _pygame: https://www.pygame.org[m
[31m-.. _Simple DirectMedia Layer library: https://www.libsdl.org[m
[31m-.. _We need your help: https://www.pygame.org/contribute.html[m
[31m-.. _Compilation wiki page: https://www.pygame.org/wiki/Compilation[m
[31m-.. _docs page: https://www.pygame.org/docs/[m
[31m-.. _GNU LGPL version 2.1: https://www.gnu.org/copyleft/lesser.html[m
[1mdiff --git a/examples/SqueletteJeu.py b/examples/SqueletteJeu.py[m
[1mnew file mode 100644[m
[1mindex 00000000..f82ee619[m
[1m--- /dev/null[m
[1m+++ b/examples/SqueletteJeu.py[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32mimport pygame[m
[32m+[m[32mimport sys[m
[32m+[m
[32m+[m[32m# Initialisation[m
[32m+[m[32mpygame.init()[m
[32m+[m[32mWIDTH, HEIGHT = 800, 600[m
[32m+[m[32mscreen = pygame.display.set_mode((WIDTH, HEIGHT))[m
[32m+[m[32mpygame.display.set_caption("Projet Tuteur√© - Pygame")[m
[32m+[m
[32m+[m[32mclock = pygame.time.Clock()[m
[32m+[m[32mrunning = True[m
[32m+[m
[32m+[m[32m# Couleurs[m
[32m+[m[32mWHITE = (255, 255, 255)[m
[32m+[m[32mBLUE = (50, 150, 255)[m
[32m+[m
[32m+[m[32m# Boucle principale du jeu[m
[32m+[m[32mwhile running:[m
[32m+[m[32m    for event in pygame.event.get():[m
[32m+[m[32m        if event.type == pygame.QUIT:[m
[32m+[m[32m            running = False[m
[32m+[m
[32m+[m[32m    screen.fill(BLUE)[m
[32m+[m[32m    pygame.display.flip()[m
[32m+[m[32m    clock.tick(60)[m
[32m+[m
[32m+[m[32mpygame.quit()[m
[32m+[m[32msys.exit()[m
[1mdiff --git a/venv/lib/python3.11/site-packages/Cython/py.typed b/notes.md[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/Cython/py.typed[m
[1mrename to notes.md[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/__init__.py b/pygame-test/tests/test_utils/__init__.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/__init__.py[m
[1mrename to pygame-test/tests/test_utils/__init__.py[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/arrinter.py b/pygame-test/tests/test_utils/arrinter.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/arrinter.py[m
[1mrename to pygame-test/tests/test_utils/arrinter.py[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/async_sub.py b/pygame-test/tests/test_utils/async_sub.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/async_sub.py[m
[1mrename to pygame-test/tests/test_utils/async_sub.py[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/buftools.py b/pygame-test/tests/test_utils/buftools.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/buftools.py[m
[1mrename to pygame-test/tests/test_utils/buftools.py[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/endian.py b/pygame-test/tests/test_utils/endian.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/endian.py[m
[1mrename to pygame-test/tests/test_utils/endian.py[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/png.py b/pygame-test/tests/test_utils/png.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/png.py[m
[1mrename to pygame-test/tests/test_utils/png.py[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/run_tests.py b/pygame-test/tests/test_utils/run_tests.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/run_tests.py[m
[1mrename to pygame-test/tests/test_utils/run_tests.py[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/test_machinery.py b/pygame-test/tests/test_utils/test_machinery.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/test_machinery.py[m
[1mrename to pygame-test/tests/test_utils/test_machinery.py[m
[1mdiff --git a/venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/test_runner.py b/pygame-test/tests/test_utils/test_runner.py[m
[1msimilarity index 100%[m
[1mrename from venv/lib/python3.11/site-packages/pygame-2.6.1-py3.11-linux-x86_64.egg/pygame/tests/test_utils/test_runner.py[m
[1mrename to pygame-test/tests/test_utils/test_runner.py[m
[1mdiff --git a/pygame/tests/test_utils/__init__.py b/pygame/tests/test_utils/__init__.py[m
[1mnew file mode 100644[m
[1mindex 00000000..a4994f28[m
[1m--- /dev/null[m
[1m+++ b/pygame/tests/test_utils/__init__.py[m
[36m@@ -0,0 +1,201 @@[m
[32m+[m[32mimport os[m
[32m+[m[32mimport pygame[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport tempfile[m
[32m+[m[32mimport time[m
[32m+[m
[32m+[m[32mis_pygame_pkg = __name__.startswith("pygame.tests.")[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m
[32m+[m
[32m+[m[32mdef tostring(row):[m
[32m+[m[32m    """Convert row of bytes to string.  Expects `row` to be an[m
[32m+[m[32m    ``array``.[m
[32m+[m[32m    """[m
[32m+[m[32m    return row.tobytes()[m
[32m+[m
[32m+[m
[32m+[m[32mdef geterror():[m
[32m+[m[32m    return sys.exc_info()[1][m
[32m+[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m
[32m+[m[32mthis_dir = os.path.dirname(os.path.abspath(__file__))[m
[32m+[m[32mtrunk_dir = os.path.split(os.path.split(this_dir)[0])[0][m
[32m+[m[32mif is_pygame_pkg:[m
[32m+[m[32m    test_module = "tests"[m
[32m+[m[32melse:[m
[32m+[m[32m    test_module = "test"[m
[32m+[m
[32m+[m
[32m+[m[32mdef trunk_relative_path(relative):[m
[32m+[m[32m    return os.path.normpath(os.path.join(trunk_dir, relative))[m
[32m+[m
[32m+[m
[32m+[m[32mdef fixture_path(path):[m
[32m+[m[32m    return trunk_relative_path(os.path.join(test_module, "fixtures", path))[m
[32m+[m
[32m+[m
[32m+[m[32mdef example_path(path):[m
[32m+[m[32m    return trunk_relative_path(os.path.join("examples", path))[m
[32m+[m
[32m+[m
[32m+[m[32msys.path.insert(0, trunk_relative_path("."))[m
[32m+[m
[32m+[m
[32m+[m[32m################################## TEMP FILES #################################[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_tmp_dir():[m
[32m+[m[32m    return tempfile.mkdtemp()[m
[32m+[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m
[32m+[m
[32m+[m[32mdef question(q):[m
[32m+[m[32m    return input(f"\n{q.rstrip(' ')} (y/n): ").lower().strip() == "y"[m
[32m+[m
[32m+[m
[32m+[m[32mdef prompt(p):[m
[32m+[m[32m    return input(f"\n{p.rstrip(' ')} (press enter to continue): ")[m
[32m+[m
[32m+[m
[32m+[m[32m#################################### HELPERS ##################################[m
[32m+[m
[32m+[m
[32m+[m[32mdef rgba_between(value, minimum=0, maximum=255):[m
[32m+[m[32m    if value < minimum:[m
[32m+[m[32m        return minimum[m
[32m+[m[32m    elif value > maximum:[m
[32m+[m[32m        return maximum[m
[32m+[m[32m    else:[m
[32m+[m[32m        return value[m
[32m+[m
[32m+[m
[32m+[m[32mdef combinations(seqs):[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    Recipe 496807 from ActiveState Python CookBook[m
[32m+[m
[32m+[m[32m    Non recursive technique for getting all possible combinations of a sequence[m
[32m+[m[32m    of sequences.[m
[32m+[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    r = [[]][m
[32m+[m[32m    for x in seqs:[m
[32m+[m[32m        r = [i + [y] for y in x for i in r][m
[32m+[m[32m    return r[m
[32m+[m
[32m+[m
[32m+[m[32mdef gradient(width, height):[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    Yields a pt and corresponding RGBA tuple, for every (width, height) combo.[m
[32m+[m[32m    Useful for generating gradients.[m
[32m+[m
[32m+[m[32m    Actual gradient may be changed, no tests rely on specific values.[m
[32m+[m
[32m+[m[32m    Used in transform.rotate lossless tests to generate a fixture.[m
[32m+[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    for l in range(width):[m
[32m+[m[32m        for t in range(height):[m
[32m+[m[32m            yield (l, t), tuple(map(rgba_between, (l, t, l, l + t)))[m
[32m+[m
[32m+[m
[32m+[m[32mdef rect_area_pts(rect):[m
[32m+[m[32m    for l in range(rect.left, rect.right):[m
[32m+[m[32m        for t in range(rect.top, rect.bottom):[m
[32m+[m[32m            yield l, t[m
[32m+[m
[32m+[m
[32m+[m[32mdef rect_perimeter_pts(rect):[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    Returns pts ((L, T) tuples) encompassing the perimeter of a rect.[m
[32m+[m
[32m+[m[32m    The order is clockwise:[m
[32m+[m
[32m+[m[32m          topleft to topright[m
[32m+[m[32m         topright to bottomright[m
[32m+[m[32m      bottomright to bottomleft[m
[32m+[m[32m       bottomleft to topleft[m
[32m+[m
[32m+[m[32m    Duplicate pts are not returned[m
[32m+[m
[32m+[m[32m    """[m
[32m+[m[32m    clock_wise_from_top_left = ([m
[32m+[m[32m        [(l, rect.top) for l in range(rect.left, rect.right)],[m
[32m+[m[32m        [(rect.right - 1, t) for t in range(rect.top + 1, rect.bottom)],[m
[32m+[m[32m        [(l, rect.bottom - 1) for l in range(rect.right - 2, rect.left - 1, -1)],[m
[32m+[m[32m        [(rect.left, t) for t in range(rect.bottom - 2, rect.top, -1)],[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m    for line in clock_wise_from_top_left:[m
[32m+[m[32m        yield from line[m
[32m+[m
[32m+[m
[32m+[m[32mdef rect_outer_bounds(rect):[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m     Returns topleft outerbound if possible and then the other pts, that are[m
[32m+[m[32m     "exclusive" bounds of the rect[m
[32m+[m
[32m+[m[32m    ?------O[m
[32m+[m[32m     |RECT|      ?|0)uterbound[m
[32m+[m[32m     |----|[m
[32m+[m[32m    O      O[m
[32m+[m
[32m+[m[32m    """[m
[32m+[m[32m    return ([(rect.left - 1, rect.top)] if rect.left else []) + [[m
[32m+[m[32m        rect.topright,[m
[32m+[m[32m        rect.bottomleft,[m
[32m+[m[32m        rect.bottomright,[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m
[32m+[m[32mdef import_submodule(module):[m
[32m+[m[32m    m = __import__(module)[m
[32m+[m[32m    for n in module.split(".")[1:]:[m
[32m+[m[32m        m = getattr(m, n)[m
[32m+[m[32m    return m[m
[32m+[m
[32m+[m
[32m+[m[32mclass SurfaceSubclass(pygame.Surface):[m
[32m+[m[32m    """A subclassed Surface to test inheritance."""[m
[32m+[m
[32m+[m[32m    def __init__(self, *args, **kwargs):[m
[32m+[m[32m        super().__init__(*args, **kwargs)[m
[32m+[m[32m        self.test_attribute = True[m
[32m+[m
[32m+[m
[32m+[m[32mdef test():[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    Lightweight test for helpers[m
[32m+[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    r = pygame.Rect(0, 0, 10, 10)[m
[32m+[m[32m    assert rect_outer_bounds(r) == [(10, 0), (0, 10), (10, 10)]  # tr # bl # br[m
[32m+[m
[32m+[m[32m    assert len(list(rect_area_pts(r))) == 100[m
[32m+[m
[32m+[m[32m    r = pygame.Rect(0, 0, 3, 3)[m
[32m+[m[32m    assert list(rect_perimeter_pts(r)) == [[m
[32m+[m[32m        (0, 0),[m
[32m+[m[32m        (1, 0),[m
[32m+[m[32m        (2, 0),  # tl -> tr[m
[32m+[m[32m        (2, 1),[m
[32m+[m[32m        (2, 2),  # tr -> br[m
[32m+[m[32m        (1, 2),[m
[32m+[m[32m        (0, 2),  # br -> bl[m
[32m+[m[32m        (0, 1),  # bl -> tl[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    print("Tests: OK")[m
[1mdiff --git a/pygame/tests/test_utils/arrinter.py b/pygame/tests/test_utils/arrinter.py[m
[1mnew file mode 100644[m
[1mindex 00000000..626913c9[m
[1m--- /dev/null[m
[1m+++ b/pygame/tests/test_utils/arrinter.py[m
[36m@@ -0,0 +1,438 @@[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport ctypes[m
[32m+[m[32mfrom ctypes import *[m
[32m+[m[32mimport unittest[m
[32m+[m
[32m+[m[32m__all__ = [[m
[32m+[m[32m    "PAI_CONTIGUOUS",[m
[32m+[m[32m    "PAI_FORTRAN",[m
[32m+[m[32m    "PAI_ALIGNED",[m
[32m+[m[32m    "PAI_NOTSWAPPED",[m
[32m+[m[32m    "PAI_WRITEABLE",[m
[32m+[m[32m    "PAI_ARR_HAS_DESCR",[m
[32m+[m[32m    "ArrayInterface",[m
[32m+[m[32m][m
[32m+[m
[32m+[m[32mif sizeof(c_uint) == sizeof(c_void_p):[m
[32m+[m[32m    c_size_t = c_uint[m
[32m+[m[32m    c_ssize_t = c_int[m
[32m+[m[32melif sizeof(c_ulong) == sizeof(c_void_p):[m
[32m+[m[32m    c_size_t = c_ulong[m
[32m+[m[32m    c_ssize_t = c_long[m
[32m+[m[32melif sizeof(c_ulonglong) == sizeof(c_void_p):[m
[32m+[m[32m    c_size_t = c_ulonglong[m
[32m+[m[32m    c_ssize_t = c_longlong[m
[32m+[m
[32m+[m
[32m+[m[32mSIZEOF_VOID_P = sizeof(c_void_p)[m
[32m+[m[32mif SIZEOF_VOID_P <= sizeof(c_int):[m
[32m+[m[32m    Py_intptr_t = c_int[m
[32m+[m[32melif SIZEOF_VOID_P <= sizeof(c_long):[m
[32m+[m[32m    Py_intptr_t = c_long[m
[32m+[m[32melif "c_longlong" in globals() and SIZEOF_VOID_P <= sizeof(c_longlong):[m
[32m+[m[32m    Py_intptr_t = c_longlong[m
[32m+[m[32melse:[m
[32m+[m[32m    raise RuntimeError("Unrecognized pointer size %i" % (SIZEOF_VOID_P,))[m
[32m+[m
[32m+[m
[32m+[m[32mclass PyArrayInterface(Structure):[m
[32m+[m[32m    _fields_ = [[m
[32m+[m[32m        ("two", c_int),[m
[32m+[m[32m        ("nd", c_int),[m
[32m+[m[32m        ("typekind", c_char),[m
[32m+[m[32m        ("itemsize", c_int),[m
[32m+[m[32m        ("flags", c_int),[m
[32m+[m[32m        ("shape", POINTER(Py_intptr_t)),[m
[32m+[m[32m        ("strides", POINTER(Py_intptr_t)),[m
[32m+[m[32m        ("data", c_void_p),[m
[32m+[m[32m        ("descr", py_object),[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m
[32m+[m[32mPAI_Ptr = POINTER(PyArrayInterface)[m
[32m+[m
[32m+[m[32mtry:[m
[32m+[m[32m    PyCObject_AsVoidPtr = pythonapi.PyCObject_AsVoidPtr[m
[32m+[m[32mexcept AttributeError:[m
[32m+[m
[32m+[m[32m    def PyCObject_AsVoidPtr(o):[m
[32m+[m[32m        raise TypeError("Not available")[m
[32m+[m
[32m+[m[32melse:[m
[32m+[m[32m    PyCObject_AsVoidPtr.restype = c_void_p[m
[32m+[m[32m    PyCObject_AsVoidPtr.argtypes = [py_object][m
[32m+[m[32m    PyCObject_GetDesc = pythonapi.PyCObject_GetDesc[m
[32m+[m[32m    PyCObject_GetDesc.restype = c_void_p[m
[32m+[m[32m    PyCObject_GetDesc.argtypes = [py_object][m
[32m+[m
[32m+[m[32mtry:[m
[32m+[m[32m    PyCapsule_IsValid = pythonapi.PyCapsule_IsValid[m
[32m+[m[32mexcept AttributeError:[m
[32m+[m
[32m+[m[32m    def PyCapsule_IsValid(capsule, name):[m
[32m+[m[32m        return 0[m
[32m+[m
[32m+[m[32melse:[m
[32m+[m[32m    PyCapsule_IsValid.restype = c_int[m
[32m+[m[32m    PyCapsule_IsValid.argtypes = [py_object, c_char_p][m
[32m+[m[32m    PyCapsule_GetPointer = pythonapi.PyCapsule_GetPointer[m
[32m+[m[32m    PyCapsule_GetPointer.restype = c_void_p[m
[32m+[m[32m    PyCapsule_GetPointer.argtypes = [py_object, c_char_p][m
[32m+[m[32m    PyCapsule_GetContext = pythonapi.PyCapsule_GetContext[m
[32m+[m[32m    PyCapsule_GetContext.restype = c_void_p[m
[32m+[m[32m    PyCapsule_GetContext.argtypes = [py_object][m
[32m+[m
[32m+[m[32mPyCapsule_Destructor = CFUNCTYPE(None, py_object)[m
[32m+[m[32mPyCapsule_New = pythonapi.PyCapsule_New[m
[32m+[m[32mPyCapsule_New.restype = py_object[m
[32m+[m[32mPyCapsule_New.argtypes = [c_void_p, c_char_p, POINTER(PyCapsule_Destructor)][m
[32m+[m
[32m+[m
[32m+[m[32mdef capsule_new(p):[m
[32m+[m[32m    return PyCapsule_New(addressof(p), None, None)[m
[32m+[m
[32m+[m
[32m+[m[32mPAI_CONTIGUOUS = 0x01[m
[32m+[m[32mPAI_FORTRAN = 0x02[m
[32m+[m[32mPAI_ALIGNED = 0x100[m
[32m+[m[32mPAI_NOTSWAPPED = 0x200[m
[32m+[m[32mPAI_WRITEABLE = 0x400[m
[32m+[m[32mPAI_ARR_HAS_DESCR = 0x800[m
[32m+[m
[32m+[m
[32m+[m[32mclass ArrayInterface:[m
[32m+[m[32m    def __init__(self, arr):[m
[32m+[m[32m        try:[m
[32m+[m[32m            self._cobj = arr.__array_struct__[m
[32m+[m[32m        except AttributeError:[m
[32m+[m[32m            raise TypeError("The array object lacks an array structure")[m
[32m+[m[32m        if not self._cobj:[m
[32m+[m[32m            raise TypeError("The array object has a NULL array structure value")[m
[32m+[m[32m        try:[m
[32m+[m[32m            vp = PyCObject_AsVoidPtr(self._cobj)[m
[32m+[m[32m        except TypeError:[m
[32m+[m[32m            if PyCapsule_IsValid(self._cobj, None):[m
[32m+[m[32m                vp = PyCapsule_GetPointer(self._cobj, None)[m
[32m+[m[32m            else:[m
[32m+[m[32m                raise TypeError("The array object has an invalid array structure")[m
[32m+[m[32m            self.desc = PyCapsule_GetContext(self._cobj)[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.desc = PyCObject_GetDesc(self._cobj)[m
[32m+[m[32m        self._inter = cast(vp, PAI_Ptr)[0][m
[32m+[m
[32m+[m[32m    def __getattr__(self, name):[m
[32m+[m[32m        if name == "typekind":[m
[32m+[m[32m            return self._inter.typekind.decode("latin-1")[m
[32m+[m[32m        return getattr(self._inter, name)[m
[32m+[m
[32m+[m[32m    def __str__(self):[m
[32m+[m[32m        if isinstance(self.desc, tuple):[m
[32m+[m[32m            ver = self.desc[0][m
[32m+[m[32m        else:[m
[32m+[m[32m            ver = "N/A"[m
[32m+[m[32m        return ([m
[32m+[m[32m            "nd: %i\n"[m
[32m+[m[32m            "typekind: %s\n"[m
[32m+[m[32m            "itemsize: %i\n"[m
[32m+[m[32m            "flags: %s\n"[m
[32m+[m[32m            "shape: %s\n"[m
[32m+[m[32m            "strides: %s\n"[m
[32m+[m[32m            "ver: %s\n"[m
[32m+[m[32m            % ([m
[32m+[m[32m                self.nd,[m
[32m+[m[32m                self.typekind,[m
[32m+[m[32m                self.itemsize,[m
[32m+[m[32m                format_flags(self.flags),[m
[32m+[m[32m                format_shape(self.nd, self.shape),[m
[32m+[m[32m                format_strides(self.nd, self.strides),[m
[32m+[m[32m                ver,[m
[32m+[m[32m            )[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m
[32m+[m[32mdef format_flags(flags):[m
[32m+[m[32m    names = [][m
[32m+[m[32m    for flag, name in [[m
[32m+[m[32m        (PAI_CONTIGUOUS, "CONTIGUOUS"),[m
[32m+[m[32m        (PAI_FORTRAN, "FORTRAN"),[m
[32m+[m[32m        (PAI_ALIGNED, "ALIGNED"),[m
[32m+[m[32m        (PAI_NOTSWAPPED, "NOTSWAPPED"),[m
[32m+[m[32m        (PAI_WRITEABLE, "WRITEABLE"),[m
[32m+[m[32m        (PAI_ARR_HAS_DESCR, "ARR_HAS_DESCR"),[m
[32m+[m[32m    ]:[m
[32m+[m[32m        if flag & flags:[m
[32m+[m[32m            names.append(name)[m
[32m+[m[32m    return ", ".join(names)[m
[32m+[m
[32m+[m
[32m+[m[32mdef format_shape(nd, shape):[m
[32m+[m[32m    return ", ".join([str(shape[i]) for i in range(nd)])[m
[32m+[m
[32m+[m
[32m+[m[32mdef format_strides(nd, strides):[m
[32m+[m[32m    return ", ".join([str(strides[i]) for i in range(nd)])[m
[32m+[m
[32m+[m
[32m+[m[32mclass Exporter:[m
[32m+[m[32m    def __init__([m
[32m+[m[32m        self, shape, typekind=None, itemsize=None, strides=None, descr=None, flags=None[m
[32m+[m[32m    ):[m
[32m+[m[32m        if typekind is None:[m
[32m+[m[32m            typekind = "u"[m
[32m+[m[32m        if itemsize is None:[m
[32m+[m[32m            itemsize = 1[m
[32m+[m[32m        if flags is None:[m
[32m+[m[32m            flags = PAI_WRITEABLE | PAI_ALIGNED | PAI_NOTSWAPPED[m
[32m+[m[32m        if descr is not None:[m
[32m+[m[32m            flags |= PAI_ARR_HAS_DESCR[m
[32m+[m[32m        if len(typekind) != 1:[m
[32m+[m[32m            raise ValueError("Argument 'typekind' must be length 1 string")[m
[32m+[m[32m        nd = len(shape)[m
[32m+[m[32m        self.typekind = typekind[m
[32m+[m[32m        self.itemsize = itemsize[m
[32m+[m[32m        self.nd = nd[m
[32m+[m[32m        self.shape = tuple(shape)[m
[32m+[m[32m        self._shape = (c_ssize_t * self.nd)(*self.shape)[m
[32m+[m[32m        if strides is None:[m
[32m+[m[32m            self._strides = (c_ssize_t * self.nd)()[m
[32m+[m[32m            self._strides[self.nd - 1] = self.itemsize[m
[32m+[m[32m            for i in range(self.nd - 1, 0, -1):[m
[32m+[m[32m                self._strides[i - 1] = self.shape[i] * self._strides[i][m
[32m+[m[32m            strides = tuple(self._strides)[m
[32m+[m[32m            self.strides = strides[m
[32m+[m[32m        elif len(strides) == nd:[m
[32m+[m[32m            self.strides = tuple(strides)[m
[32m+[m[32m            self._strides = (c_ssize_t * self.nd)(*self.strides)[m
[32m+[m[32m        else:[m
[32m+[m[32m            raise ValueError("Mismatch in length of strides and shape")[m
[32m+[m[32m        self.descr = descr[m
[32m+[m[32m        if self.is_contiguous("C"):[m
[32m+[m[32m            flags |= PAI_CONTIGUOUS[m
[32m+[m[32m        if self.is_contiguous("F"):[m
[32m+[m[32m            flags |= PAI_FORTRAN[m
[32m+[m[32m        self.flags = flags[m
[32m+[m[32m        sz = max(shape[i] * strides[i] for i in range(nd))[m
[32m+[m[32m        self._data = (c_ubyte * sz)()[m
[32m+[m[32m        self.data = addressof(self._data)[m
[32m+[m[32m        self._inter = PyArrayInterface([m
[32m+[m[32m            2,[m
[32m+[m[32m            nd,[m
[32m+[m[32m            typekind.encode("latin_1"),[m
[32m+[m[32m            itemsize,[m
[32m+[m[32m            flags,[m
[32m+[m[32m            self._shape,[m
[32m+[m[32m            self._strides,[m
[32m+[m[32m            self.data,[m
[32m+[m[32m            descr,[m
[32m+[m[32m        )[m
[32m+[m[32m        self.len = itemsize[m
[32m+[m[32m        for i in range(nd):[m
[32m+[m[32m            self.len *= self.shape[i][m
[32m+[m
[32m+[m[32m    __array_struct__ = property(lambda self: capsule_new(self._inter))[m
[32m+[m
[32m+[m[32m    def is_contiguous(self, fortran):[m
[32m+[m[32m        if fortran in "CA":[m
[32m+[m[32m            if self.strides[-1] == self.itemsize:[m
[32m+[m[32m                for i in range(self.nd - 1, 0, -1):[m
[32m+[m[32m                    if self.strides[i - 1] != self.shape[i] * self.strides[i]:[m
[32m+[m[32m                        break[m
[32m+[m[32m                else:[m
[32m+[m[32m                    return True[m
[32m+[m[32m        if fortran in "FA":[m
[32m+[m[32m            if self.strides[0] == self.itemsize:[m
[32m+[m[32m                for i in range(0, self.nd - 1):[m
[32m+[m[32m                    if self.strides[i + 1] != self.shape[i] * self.strides[i]:[m
[32m+[m[32m                        break[m
[32m+[m[32m                else:[m
[32m+[m[32m                    return True[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m
[32m+[m[32mclass Array(Exporter):[m
[32m+[m[32m    _ctypes = {[m
[32m+[m[32m        ("u", 1): c_uint8,[m
[32m+[m[32m        ("u", 2): c_uint16,[m
[32m+[m[32m        ("u", 4): c_uint32,[m
[32m+[m[32m        ("u", 8): c_uint64,[m
[32m+[m[32m        ("i", 1): c_int8,[m
[32m+[m[32m        ("i", 2): c_int16,[m
[32m+[m[32m        ("i", 4): c_int32,[m
[32m+[m[32m        ("i", 8): c_int64,[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    def __init__(self, *args, **kwds):[m
[32m+[m[32m        super().__init__(*args, **kwds)[m
[32m+[m[32m        try:[m
[32m+[m[32m            if self.flags & PAI_NOTSWAPPED:[m
[32m+[m[32m                ct = self._ctypes[self.typekind, self.itemsize][m
[32m+[m[32m            elif c_int.__ctype_le__ is c_int:[m
[32m+[m[32m                ct = self._ctypes[self.typekind, self.itemsize].__ctype_be__[m
[32m+[m[32m            else:[m
[32m+[m[32m                ct = self._ctypes[self.typekind, self.itemsize].__ctype_le__[m
[32m+[m[32m        except KeyError:[m
[32m+[m[32m            ct = c_uint8 * self.itemsize[m
[32m+[m[32m        self._ctype = ct[m
[32m+[m[32m        self._ctype_p = POINTER(ct)[m
[32m+[m
[32m+[m[32m    def __getitem__(self, key):[m
[32m+[m[32m        return cast(self._addr_at(key), self._ctype_p)[0][m
[32m+[m
[32m+[m[32m    def __setitem__(self, key, value):[m
[32m+[m[32m        cast(self._addr_at(key), self._ctype_p)[0] = value[m
[32m+[m
[32m+[m[32m    def _addr_at(self, key):[m
[32m+[m[32m        if not isinstance(key, tuple):[m
[32m+[m[32m            key = (key,)[m
[32m+[m[32m        if len(key) != self.nd:[m
[32m+[m[32m            raise ValueError("wrong number of indexes")[m
[32m+[m[32m        for i in range(self.nd):[m
[32m+[m[32m            if not (0 <= key[i] < self.shape[i]):[m
[32m+[m[32m                raise IndexError(f"index {i} out of range")[m
[32m+[m[32m        return self.data + sum(i * s for i, s in zip(key, self.strides))[m
[32m+[m
[32m+[m
[32m+[m[32mclass ExporterTest(unittest.TestCase):[m
[32m+[m[32m    def test_strides(self):[m
[32m+[m[32m        self.check_args(0, (10,), "u", (2,), 20, 20, 2)[m
[32m+[m[32m        self.check_args(0, (5, 3), "u", (6, 2), 30, 30, 2)[m
[32m+[m[32m        self.check_args(0, (7, 3, 5), "u", (30, 10, 2), 210, 210, 2)[m
[32m+[m[32m        self.check_args(0, (13, 5, 11, 3), "u", (330, 66, 6, 2), 4290, 4290, 2)[m
[32m+[m[32m        self.check_args(3, (7, 3, 5), "i", (2, 14, 42), 210, 210, 2)[m
[32m+[m[32m        self.check_args(3, (7, 3, 5), "x", (2, 16, 48), 210, 240, 2)[m
[32m+[m[32m        self.check_args(3, (13, 5, 11, 3), "%", (440, 88, 8, 2), 4290, 5720, 2)[m
[32m+[m[32m        self.check_args(3, (7, 5), "-", (15, 3), 105, 105, 3)[m
[32m+[m[32m        self.check_args(3, (7, 5), "*", (3, 21), 105, 105, 3)[m
[32m+[m[32m        self.check_args(3, (7, 5), " ", (3, 24), 105, 120, 3)[m
[32m+[m
[32m+[m[32m    def test_is_contiguous(self):[m
[32m+[m[32m        a = Exporter((10,), itemsize=2)[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("C"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("F"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        a = Exporter((10, 4), itemsize=2)[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("C"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("F"))[m
[32m+[m[32m        a = Exporter((13, 5, 11, 3), itemsize=2, strides=(330, 66, 6, 2))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("C"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("F"))[m
[32m+[m[32m        a = Exporter((10, 4), itemsize=2, strides=(2, 20))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("F"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("C"))[m
[32m+[m[32m        a = Exporter((13, 5, 11, 3), itemsize=2, strides=(2, 26, 130, 1430))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("F"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("C"))[m
[32m+[m[32m        a = Exporter((2, 11, 6, 4), itemsize=2, strides=(576, 48, 8, 2))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("A"))[m
[32m+[m[32m        a = Exporter((2, 11, 6, 4), itemsize=2, strides=(2, 4, 48, 288))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("A"))[m
[32m+[m[32m        a = Exporter((3, 2, 2), itemsize=2, strides=(16, 8, 4))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("A"))[m
[32m+[m[32m        a = Exporter((3, 2, 2), itemsize=2, strides=(4, 12, 24))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("A"))[m
[32m+[m
[32m+[m[32m    def check_args([m
[32m+[m[32m        self, call_flags, shape, typekind, strides, length, bufsize, itemsize, offset=0[m
[32m+[m[32m    ):[m
[32m+[m[32m        if call_flags & 1:[m
[32m+[m[32m            typekind_arg = typekind[m
[32m+[m[32m        else:[m
[32m+[m[32m            typekind_arg = None[m
[32m+[m[32m        if call_flags & 2:[m
[32m+[m[32m            strides_arg = strides[m
[32m+[m[32m        else:[m
[32m+[m[32m            strides_arg = None[m
[32m+[m[32m        a = Exporter(shape, itemsize=itemsize, strides=strides_arg)[m
[32m+[m[32m        self.assertEqual(sizeof(a._data), bufsize)[m
[32m+[m[32m        self.assertEqual(a.data, ctypes.addressof(a._data) + offset)[m
[32m+[m[32m        m = ArrayInterface(a)[m
[32m+[m[32m        self.assertEqual(m.data, a.data)[m
[32m+[m[32m        self.assertEqual(m.itemsize, itemsize)[m
[32m+[m[32m        self.assertEqual(tuple(m.shape[0 : m.nd]), shape)[m
[32m+[m[32m        self.assertEqual(tuple(m.strides[0 : m.nd]), strides)[m
[32m+[m
[32m+[m
[32m+[m[32mclass ArrayTest(unittest.TestCase):[m
[32m+[m[32m    def __init__(self, *args, **kwds):[m
[32m+[m[32m        unittest.TestCase.__init__(self, *args, **kwds)[m
[32m+[m[32m        self.a = Array((20, 15), "i", 4)[m
[32m+[m
[32m+[m[32m    def setUp(self):[m
[32m+[m[32m        # Every test starts with a zeroed array.[m
[32m+[m[32m        memset(self.a.data, 0, sizeof(self.a._data))[m
[32m+[m
[32m+[m[32m    def test__addr_at(self):[m
[32m+[m[32m        a = self.a[m
[32m+[m[32m        self.assertEqual(a._addr_at((0, 0)), a.data)[m
[32m+[m[32m        self.assertEqual(a._addr_at((0, 1)), a.data + 4)[m
[32m+[m[32m        self.assertEqual(a._addr_at((1, 0)), a.data + 60)[m
[32m+[m[32m        self.assertEqual(a._addr_at((1, 1)), a.data + 64)[m
[32m+[m
[32m+[m[32m    def test_indices(self):[m
[32m+[m[32m        a = self.a[m
[32m+[m[32m        self.assertEqual(a[0, 0], 0)[m
[32m+[m[32m        self.assertEqual(a[19, 0], 0)[m
[32m+[m[32m        self.assertEqual(a[0, 14], 0)[m
[32m+[m[32m        self.assertEqual(a[19, 14], 0)[m
[32m+[m[32m        self.assertEqual(a[5, 8], 0)[m
[32m+[m[32m        a[0, 0] = 12[m
[32m+[m[32m        a[5, 8] = 99[m
[32m+[m[32m        self.assertEqual(a[0, 0], 12)[m
[32m+[m[32m        self.assertEqual(a[5, 8], 99)[m
[32m+[m[32m        self.assertRaises(IndexError, a.__getitem__, (-1, 0))[m
[32m+[m[32m        self.assertRaises(IndexError, a.__getitem__, (0, -1))[m
[32m+[m[32m        self.assertRaises(IndexError, a.__getitem__, (20, 0))[m
[32m+[m[32m        self.assertRaises(IndexError, a.__getitem__, (0, 15))[m
[32m+[m[32m        self.assertRaises(ValueError, a.__getitem__, 0)[m
[32m+[m[32m        self.assertRaises(ValueError, a.__getitem__, (0, 0, 0))[m
[32m+[m[32m        a = Array((3,), "i", 4)[m
[32m+[m[32m        a[1] = 333[m
[32m+[m[32m        self.assertEqual(a[1], 333)[m
[32m+[m
[32m+[m[32m    def test_typekind(self):[m
[32m+[m[32m        a = Array((1,), "i", 4)[m
[32m+[m[32m        self.assertTrue(a._ctype is c_int32)[m
[32m+[m[32m        self.assertTrue(a._ctype_p is POINTER(c_int32))[m
[32m+[m[32m        a = Array((1,), "u", 4)[m
[32m+[m[32m        self.assertTrue(a._ctype is c_uint32)[m
[32m+[m[32m        self.assertTrue(a._ctype_p is POINTER(c_uint32))[m
[32m+[m[32m        a = Array((1,), "f", 4)  # float types unsupported: size system dependent[m
[32m+[m[32m        ct = a._ctype[m
[32m+[m[32m        self.assertTrue(issubclass(ct, ctypes.Array))[m
[32m+[m[32m        self.assertEqual(sizeof(ct), 4)[m
[32m+[m
[32m+[m[32m    def test_itemsize(self):[m
[32m+[m[32m        for size in [1, 2, 4, 8]:[m
[32m+[m[32m            a = Array((1,), "i", size)[m
[32m+[m[32m            ct = a._ctype[m
[32m+[m[32m            self.assertTrue(issubclass(ct, ctypes._SimpleCData))[m
[32m+[m[32m            self.assertEqual(sizeof(ct), size)[m
[32m+[m
[32m+[m[32m    def test_oddball_itemsize(self):[m
[32m+[m[32m        for size in [3, 5, 6, 7, 9]:[m
[32m+[m[32m            a = Array((1,), "i", size)[m
[32m+[m[32m            ct = a._ctype[m
[32m+[m[32m            self.assertTrue(issubclass(ct, ctypes.Array))[m
[32m+[m[32m            self.assertEqual(sizeof(ct), size)[m
[32m+[m
[32m+[m[32m    def test_byteswapped(self):[m
[32m+[m[32m        a = Array((1,), "u", 4, flags=(PAI_ALIGNED | PAI_WRITEABLE))[m
[32m+[m[32m        ct = a._ctype[m
[32m+[m[32m        self.assertTrue(ct is not c_uint32)[m
[32m+[m[32m        if sys.byteorder == "little":[m
[32m+[m[32m            self.assertTrue(ct is c_uint32.__ctype_be__)[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.assertTrue(ct is c_uint32.__ctype_le__)[m
[32m+[m[32m        i = 0xA0B0C0D[m
[32m+[m[32m        n = c_uint32(i)[m
[32m+[m[32m        a[0] = i[m
[32m+[m[32m        self.assertEqual(a[0], i)[m
[32m+[m[32m        self.assertEqual(a._data[0:4], cast(addressof(n), POINTER(c_uint8))[3:-1:-1])[m
[32m+[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    unittest.main()[m
[1mdiff --git a/pygame/tests/test_utils/async_sub.py b/pygame/tests/test_utils/async_sub.py[m
[1mnew file mode 100644[m
[1mindex 00000000..560d377b[m
[1m--- /dev/null[m
[1m+++ b/pygame/tests/test_utils/async_sub.py[m
[36m@@ -0,0 +1,301 @@[m
[32m+[m[32m################################################################################[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mModification of http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/440554[m
[32m+[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32m#################################### IMPORTS ###################################[m
[32m+[m
[32m+[m[32mimport os[m
[32m+[m[32mimport platform[m
[32m+[m[32mimport subprocess[m
[32m+[m[32mimport errno[m
[32m+[m[32mimport time[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport unittest[m
[32m+[m[32mimport tempfile[m
[32m+[m
[32m+[m
[32m+[m[32mdef geterror():[m
[32m+[m[32m    return sys.exc_info()[1][m
[32m+[m
[32m+[m
[32m+[m[32mnull_byte = "\x00".encode("ascii")[m
[32m+[m
[32m+[m[32mif platform.system() == "Windows":[m
[32m+[m
[32m+[m[32m    def encode(s):[m
[32m+[m[32m        return s.encode("ascii")[m
[32m+[m
[32m+[m[32m    def decode(b):[m
[32m+[m[32m        return b.decode("ascii")[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        import ctypes[m
[32m+[m[32m        from ctypes.wintypes import DWORD[m
[32m+[m
[32m+[m[32m        kernel32 = ctypes.windll.kernel32[m
[32m+[m[32m        TerminateProcess = ctypes.windll.kernel32.TerminateProcess[m
[32m+[m
[32m+[m[32m        def WriteFile(handle, data, ol=None):[m
[32m+[m[32m            c_written = DWORD()[m
[32m+[m[32m            success = ctypes.windll.kernel32.WriteFile([m
[32m+[m[32m                handle,[m
[32m+[m[32m                ctypes.create_string_buffer(encode(data)),[m
[32m+[m[32m                len(data),[m
[32m+[m[32m                ctypes.byref(c_written),[m
[32m+[m[32m                ol,[m
[32m+[m[32m            )[m
[32m+[m[32m            return ctypes.windll.kernel32.GetLastError(), c_written.value[m
[32m+[m
[32m+[m[32m        def ReadFile(handle, desired_bytes, ol=None):[m
[32m+[m[32m            c_read = DWORD()[m
[32m+[m[32m            buffer = ctypes.create_string_buffer(desired_bytes + 1)[m
[32m+[m[32m            success = ctypes.windll.kernel32.ReadFile([m
[32m+[m[32m                handle, buffer, desired_bytes, ctypes.byref(c_read), ol[m
[32m+[m[32m            )[m
[32m+[m[32m            buffer[c_read.value] = null_byte[m
[32m+[m[32m            return ctypes.windll.kernel32.GetLastError(), decode(buffer.value)[m
[32m+[m
[32m+[m[32m        def PeekNamedPipe(handle, desired_bytes):[m
[32m+[m[32m            c_avail = DWORD()[m
[32m+[m[32m            c_message = DWORD()[m
[32m+[m[32m            if desired_bytes > 0:[m
[32m+[m[32m                c_read = DWORD()[m
[32m+[m[32m                buffer = ctypes.create_string_buffer(desired_bytes + 1)[m
[32m+[m[32m                success = ctypes.windll.kernel32.PeekNamedPipe([m
[32m+[m[32m                    handle,[m
[32m+[m[32m                    buffer,[m
[32m+[m[32m                    desired_bytes,[m
[32m+[m[32m                    ctypes.byref(c_read),[m
[32m+[m[32m                    ctypes.byref(c_avail),[m
[32m+[m[32m                    ctypes.byref(c_message),[m
[32m+[m[32m                )[m
[32m+[m[32m                buffer[c_read.value] = null_byte[m
[32m+[m[32m                return decode(buffer.value), c_avail.value, c_message.value[m
[32m+[m[32m            else:[m
[32m+[m[32m                success = ctypes.windll.kernel32.PeekNamedPipe([m
[32m+[m[32m                    handle,[m
[32m+[m[32m                    None,[m
[32m+[m[32m                    desired_bytes,[m
[32m+[m[32m                    None,[m
[32m+[m[32m                    ctypes.byref(c_avail),[m
[32m+[m[32m                    ctypes.byref(c_message),[m
[32m+[m[32m                )[m
[32m+[m[32m                return "", c_avail.value, c_message.value[m
[32m+[m
[32m+[m[32m    except ImportError:[m
[32m+[m[32m        from win32file import ReadFile, WriteFile[m
[32m+[m[32m        from win32pipe import PeekNamedPipe[m
[32m+[m[32m        from win32api import TerminateProcess[m
[32m+[m[32m    import msvcrt[m
[32m+[m
[32m+[m[32melse:[m
[32m+[m[32m    from signal import SIGINT, SIGTERM, SIGKILL[m
[32m+[m[32m    import select[m
[32m+[m[32m    import fcntl[m
[32m+[m
[32m+[m[32m################################### CONSTANTS ##################################[m
[32m+[m
[32m+[m[32mPIPE = subprocess.PIPE[m
[32m+[m
[32m+[m[32m################################################################################[m
[32m+[m
[32m+[m
[32m+[m[32mclass Popen(subprocess.Popen):[m
[32m+[m[32m    def recv(self, maxsize=None):[m
[32m+[m[32m        return self._recv("stdout", maxsize)[m
[32m+[m
[32m+[m[32m    def recv_err(self, maxsize=None):[m
[32m+[m[32m        return self._recv("stderr", maxsize)[m
[32m+[m
[32m+[m[32m    def send_recv(self, input="", maxsize=None):[m
[32m+[m[32m        return self.send(input), self.recv(maxsize), self.recv_err(maxsize)[m
[32m+[m
[32m+[m[32m    def read_async(self, wait=0.1, e=1, tr=5, stderr=0):[m
[32m+[m[32m        if tr < 1:[m
[32m+[m[32m            tr = 1[m
[32m+[m[32m        x = time.time() + wait[m
[32m+[m[32m        y = [][m
[32m+[m[32m        r = ""[m
[32m+[m[32m        pr = self.recv[m
[32m+[m[32m        if stderr:[m
[32m+[m[32m            pr = self.recv_err[m
[32m+[m[32m        while time.time() < x or r:[m
[32m+[m[32m            r = pr()[m
[32m+[m[32m            if r is None:[m
[32m+[m[32m                if e:[m
[32m+[m[32m                    raise Exception("Other end disconnected!")[m
[32m+[m[32m                else:[m
[32m+[m[32m                    break[m
[32m+[m[32m            elif r:[m
[32m+[m[32m                y.append(r)[m
[32m+[m[32m            else:[m
[32m+[m[32m                time.sleep(max((x - time.time()) / tr, 0))[m
[32m+[m[32m        return "".join(y)[m
[32m+[m
[32m+[m[32m    def send_all(self, data):[m
[32m+[m[32m        while len(data):[m
[32m+[m[32m            sent = self.send(data)[m
[32m+[m[32m            if sent is None:[m
[32m+[m[32m                raise Exception("Other end disconnected!")[m
[32m+[m[32m            data = memoryview(data, sent)[m
[32m+[m
[32m+[m[32m    def get_conn_maxsize(self, which, maxsize):[m
[32m+[m[32m        if maxsize is None:[m
[32m+[m[32m            maxsize = 1024[m
[32m+[m[32m        elif maxsize < 1:[m
[32m+[m[32m            maxsize = 1[m
[32m+[m[32m        return getattr(self, which), maxsize[m
[32m+[m
[32m+[m[32m    def _close(self, which):[m
[32m+[m[32m        getattr(self, which).close()[m
[32m+[m[32m        setattr(self, which, None)[m
[32m+[m
[32m+[m[32m    if platform.system() == "Windows":[m
[32m+[m
[32m+[m[32m        def kill(self):[m
[32m+[m[32m            # Recipes[m
[32m+[m[32m            # http://me.in-berlin.de/doc/python/faq/windows.html#how-do-i-emulate-os-kill-in-windows[m
[32m+[m[32m            # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/347462[m
[32m+[m
[32m+[m[32m            """kill function for Win32"""[m
[32m+[m[32m            TerminateProcess(int(self._handle), 0)  # returns None[m
[32m+[m
[32m+[m[32m        def send(self, input):[m
[32m+[m[32m            if not self.stdin:[m
[32m+[m[32m                return None[m
[32m+[m
[32m+[m[32m            try:[m
[32m+[m[32m                x = msvcrt.get_osfhandle(self.stdin.fileno())[m
[32m+[m[32m                (errCode, written) = WriteFile(x, input)[m
[32m+[m[32m            except ValueError:[m
[32m+[m[32m                return self._close("stdin")[m
[32m+[m[32m            except (subprocess.pywintypes.error, Exception):[m
[32m+[m[32m                if geterror()[0] in (109, errno.ESHUTDOWN):[m
[32m+[m[32m                    return self._close("stdin")[m
[32m+[m[32m                raise[m
[32m+[m
[32m+[m[32m            return written[m
[32m+[m
[32m+[m[32m        def _recv(self, which, maxsize):[m
[32m+[m[32m            conn, maxsize = self.get_conn_maxsize(which, maxsize)[m
[32m+[m[32m            if conn is None:[m
[32m+[m[32m                return None[m
[32m+[m
[32m+[m[32m            try:[m
[32m+[m[32m                x = msvcrt.get_osfhandle(conn.fileno())[m
[32m+[m[32m                (read, nAvail, nMessage) = PeekNamedPipe(x, 0)[m
[32m+[m[32m                if maxsize < nAvail:[m
[32m+[m[32m                    nAvail = maxsize[m
[32m+[m[32m                if nAvail > 0:[m
[32m+[m[32m                    (errCode, read) = ReadFile(x, nAvail, None)[m
[32m+[m[32m            except ValueError:[m
[32m+[m[32m                return self._close(which)[m
[32m+[m[32m            except (subprocess.pywintypes.error, Exception):[m
[32m+[m[32m                if geterror()[0] in (109, errno.ESHUTDOWN):[m
[32m+[m[32m                    return self._close(which)[m
[32m+[m[32m                raise[m
[32m+[m
[32m+[m[32m            if self.universal_newlines:[m
[32m+[m[32m                # Translate newlines. For Python 3.x assume read is text.[m
[32m+[m[32m                # If bytes then another solution is needed.[m
[32m+[m[32m                read = read.replace("\r\n", "\n").replace("\r", "\n")[m
[32m+[m[32m            return read[m
[32m+[m
[32m+[m[32m    else:[m
[32m+[m
[32m+[m[32m        def kill(self):[m
[32m+[m[32m            for i, sig in enumerate([SIGTERM, SIGKILL] * 2):[m
[32m+[m[32m                if i % 2 == 0:[m
[32m+[m[32m                    os.kill(self.pid, sig)[m
[32m+[m[32m                time.sleep((i * (i % 2) / 5.0) + 0.01)[m
[32m+[m
[32m+[m[32m                killed_pid, stat = os.waitpid(self.pid, os.WNOHANG)[m
[32m+[m[32m                if killed_pid != 0:[m
[32m+[m[32m                    return[m
[32m+[m
[32m+[m[32m        def send(self, input):[m
[32m+[m[32m            if not self.stdin:[m
[32m+[m[32m                return None[m
[32m+[m
[32m+[m[32m            if not select.select([], [self.stdin], [], 0)[1]:[m
[32m+[m[32m                return 0[m
[32m+[m
[32m+[m[32m            try:[m
[32m+[m[32m                written = os.write(self.stdin.fileno(), input)[m
[32m+[m[32m            except OSError:[m
[32m+[m[32m                if geterror()[0] == errno.EPIPE:  # broken pipe[m
[32m+[m[32m                    return self._close("stdin")[m
[32m+[m[32m                raise[m
[32m+[m
[32m+[m[32m            return written[m
[32m+[m
[32m+[m[32m        def _recv(self, which, maxsize):[m
[32m+[m[32m            conn, maxsize = self.get_conn_maxsize(which, maxsize)[m
[32m+[m[32m            if conn is None:[m
[32m+[m[32m                return None[m
[32m+[m
[32m+[m[32m            if not select.select([conn], [], [], 0)[0]:[m
[32m+[m[32m                return ""[m
[32m+[m
[32m+[m[32m            r = conn.read(maxsize)[m
[32m+[m[32m            if not r:[m
[32m+[m[32m                return self._close(which)[m
[32m+[m
[32m+[m[32m            if self.universal_newlines:[m
[32m+[m[32m                r = r.replace("\r\n", "\n").replace("\r", "\n")[m
[32m+[m[32m            return r[m
[32m+[m
[32m+[m
[32m+[m[32m################################################################################[m
[32m+[m
[32m+[m
[32m+[m[32mdef proc_in_time_or_kill(cmd, time_out, wd=None, env=None):[m
[32m+[m[32m    proc = Popen([m
[32m+[m[32m        cmd,[m
[32m+[m[32m        cwd=wd,[m
[32m+[m[32m        env=env,[m
[32m+[m[32m        stdin=subprocess.PIPE,[m
[32m+[m[32m        stdout=subprocess.PIPE,[m
[32m+[m[32m        stderr=subprocess.STDOUT,[m
[32m+[m[32m        universal_newlines=1,[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m    ret_code = None[m
[32m+[m[32m    response = [][m
[32m+[m
[32m+[m[32m    t = time.time()[m
[32m+[m[32m    while ret_code is None and ((time.time() - t) < time_out):[m
[32m+[m[32m        ret_code = proc.poll()[m
[32m+[m[32m        response += [proc.read_async(wait=0.1, e=0)][m
[32m+[m
[32m+[m[32m    if ret_code is None:[m
[32m+[m[32m        ret_code = f'"Process timed out (time_out = {time_out} secs) '[m
[32m+[m[32m        try:[m
[32m+[m[32m            proc.kill()[m
[32m+[m[32m            ret_code += 'and was successfully terminated"'[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            ret_code += f'and termination failed (exception: {geterror()})"'[m
[32m+[m
[32m+[m[32m    return ret_code, "".join(response)[m
[32m+[m
[32m+[m
[32m+[m[32m################################################################################[m
[32m+[m
[32m+[m
[32m+[m[32mclass AsyncTest(unittest.TestCase):[m
[32m+[m[32m    def test_proc_in_time_or_kill(self):[m
[32m+[m[32m        ret_code, response = proc_in_time_or_kill([m
[32m+[m[32m            [sys.executable, "-c", "while True: pass"], time_out=1[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.assertIn("rocess timed out", ret_code)[m
[32m+[m[32m        self.assertIn("successfully terminated", ret_code)[m
[32m+[m
[32m+[m
[32m+[m[32m################################################################################[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    unittest.main()[m
[1mdiff --git a/pygame/tests/test_utils/buftools.py b/pygame/tests/test_utils/buftools.py[m
[1mnew file mode 100644[m
[1mindex 00000000..de1f3169[m
[1m--- /dev/null[m
[1m+++ b/pygame/tests/test_utils/buftools.py[m
[36m@@ -0,0 +1,607 @@[m
[32m+[m[32m"""Module pygame.tests.test_utils.array[m
[32m+[m
[32m+[m[32mExport the Exporter and Importer classes.[m
[32m+[m
[32m+[m[32mClass Exporter has configurable shape and strides. Exporter objects[m
[32m+[m[32mprovide a convenient target for unit tests on Pygame objects and functions[m
[32m+[m[32mthat import a new buffer interface.[m
[32m+[m
[32m+[m[32mClass Importer imports a buffer interface with the given PyBUF_* flags.[m
[32m+[m[32mIt returns NULL Py_buffer fields as None. The shape, strides, and suboffsets[m
[32m+[m[32marrays are returned as tuples of ints. All Py_buffer field properties are[m
[32m+[m[32mread-only. This class is useful in comparing exported buffer interfaces[m
[32m+[m[32mwith the actual request. The simular Python builtin memoryview currently[m
[32m+[m[32mdoes not support configurable PyBUF_* flags.[m
[32m+[m
[32m+[m[32mThis module contains its own unit tests. When Pygame is installed, these tests[m
[32m+[m[32mcan be run with the following command line statement:[m
[32m+[m
[32m+[m[32mpython -m pygame.tests.test_utils.array[m
[32m+[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport pygame[m
[32m+[m
[32m+[m[32mif not pygame.HAVE_NEWBUF:[m
[32m+[m[32m    emsg = "This Pygame build does not support the new buffer protocol"[m
[32m+[m[32m    raise ImportError(emsg)[m
[32m+[m[32mimport pygame.newbuffer[m
[32m+[m[32mfrom pygame.newbuffer import ([m
[32m+[m[32m    PyBUF_SIMPLE,[m
[32m+[m[32m    PyBUF_FORMAT,[m
[32m+[m[32m    PyBUF_ND,[m
[32m+[m[32m    PyBUF_WRITABLE,[m
[32m+[m[32m    PyBUF_STRIDES,[m
[32m+[m[32m    PyBUF_C_CONTIGUOUS,[m
[32m+[m[32m    PyBUF_F_CONTIGUOUS,[m
[32m+[m[32m    PyBUF_ANY_CONTIGUOUS,[m
[32m+[m[32m    PyBUF_INDIRECT,[m
[32m+[m[32m    PyBUF_STRIDED,[m
[32m+[m[32m    PyBUF_STRIDED_RO,[m
[32m+[m[32m    PyBUF_RECORDS,[m
[32m+[m[32m    PyBUF_RECORDS_RO,[m
[32m+[m[32m    PyBUF_FULL,[m
[32m+[m[32m    PyBUF_FULL_RO,[m
[32m+[m[32m    PyBUF_CONTIG,[m
[32m+[m[32m    PyBUF_CONTIG_RO,[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mimport unittest[m
[32m+[m[32mimport ctypes[m
[32m+[m[32mimport operator[m
[32m+[m[32mfrom functools import reduce[m
[32m+[m
[32m+[m[32m__all__ = ["Exporter", "Importer"][m
[32m+[m
[32m+[m[32mtry:[m
[32m+[m[32m    ctypes.c_ssize_t[m
[32m+[m[32mexcept AttributeError:[m
[32m+[m[32m    void_p_sz = ctypes.sizeof(ctypes.c_void_p)[m
[32m+[m[32m    if ctypes.sizeof(ctypes.c_short) == void_p_sz:[m
[32m+[m[32m        ctypes.c_ssize_t = ctypes.c_short[m
[32m+[m[32m    elif ctypes.sizeof(ctypes.c_int) == void_p_sz:[m
[32m+[m[32m        ctypes.c_ssize_t = ctypes.c_int[m
[32m+[m[32m    elif ctypes.sizeof(ctypes.c_long) == void_p_sz:[m
[32m+[m[32m        ctypes.c_ssize_t = ctypes.c_long[m
[32m+[m[32m    elif ctypes.sizeof(ctypes.c_longlong) == void_p_sz:[m
[32m+[m[32m        ctypes.c_ssize_t = ctypes.c_longlong[m
[32m+[m[32m    else:[m
[32m+[m[32m        raise RuntimeError("Cannot set c_ssize_t: sizeof(void *) is %i" % void_p_sz)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _prop_get(fn):[m
[32m+[m[32m    return property(fn)[m
[32m+[m
[32m+[m
[32m+[m[32mclass Exporter(pygame.newbuffer.BufferMixin):[m
[32m+[m[32m    """An object that exports a multi-dimension new buffer interface[m
[32m+[m
[32m+[m[32m    The only array operation this type supports is to export a buffer.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    prefixes = {[m
[32m+[m[32m        "@": "",[m
[32m+[m[32m        "=": "=",[m
[32m+[m[32m        "<": "=",[m
[32m+[m[32m        ">": "=",[m
[32m+[m[32m        "!": "=",[m
[32m+[m[32m        "2": "2",[m
[32m+[m[32m        "3": "3",[m
[32m+[m[32m        "4": "4",[m
[32m+[m[32m        "5": "5",[m
[32m+[m[32m        "6": "6",[m
[32m+[m[32m        "7": "7",[m
[32m+[m[32m        "8": "8",[m
[32m+[m[32m        "9": "9",[m
[32m+[m[32m    }[m
[32m+[m[32m    types = {[m
[32m+[m[32m        "c": ctypes.c_char,[m
[32m+[m[32m        "b": ctypes.c_byte,[m
[32m+[m[32m        "B": ctypes.c_ubyte,[m
[32m+[m[32m        "=c": ctypes.c_int8,[m
[32m+[m[32m        "=b": ctypes.c_int8,[m
[32m+[m[32m        "=B": ctypes.c_uint8,[m
[32m+[m[32m        "?": ctypes.c_bool,[m
[32m+[m[32m        "=?": ctypes.c_int8,[m
[32m+[m[32m        "h": ctypes.c_short,[m
[32m+[m[32m        "H": ctypes.c_ushort,[m
[32m+[m[32m        "=h": ctypes.c_int16,[m
[32m+[m[32m        "=H": ctypes.c_uint16,[m
[32m+[m[32m        "i": ctypes.c_int,[m
[32m+[m[32m        "I": ctypes.c_uint,[m
[32m+[m[32m        "=i": ctypes.c_int32,[m
[32m+[m[32m        "=I": ctypes.c_uint32,[m
[32m+[m[32m        "l": ctypes.c_long,[m
[32m+[m[32m        "L": ctypes.c_ulong,[m
[32m+[m[32m        "=l": ctypes.c_int32,[m
[32m+[m[32m        "=L": ctypes.c_uint32,[m
[32m+[m[32m        "q": ctypes.c_longlong,[m
[32m+[m[32m        "Q": ctypes.c_ulonglong,[m
[32m+[m[32m        "=q": ctypes.c_int64,[m
[32m+[m[32m        "=Q": ctypes.c_uint64,[m
[32m+[m[32m        "f": ctypes.c_float,[m
[32m+[m[32m        "d": ctypes.c_double,[m
[32m+[m[32m        "P": ctypes.c_void_p,[m
[32m+[m[32m        "x": ctypes.c_ubyte * 1,[m
[32m+[m[32m        "2x": ctypes.c_ubyte * 2,[m
[32m+[m[32m        "3x": ctypes.c_ubyte * 3,[m
[32m+[m[32m        "4x": ctypes.c_ubyte * 4,[m
[32m+[m[32m        "5x": ctypes.c_ubyte * 5,[m
[32m+[m[32m        "6x": ctypes.c_ubyte * 6,[m
[32m+[m[32m        "7x": ctypes.c_ubyte * 7,[m
[32m+[m[32m        "8x": ctypes.c_ubyte * 8,[m
[32m+[m[32m        "9x": ctypes.c_ubyte * 9,[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    def __init__(self, shape, format=None, strides=None, readonly=None, itemsize=None):[m
[32m+[m[32m        if format is None:[m
[32m+[m[32m            format = "B"[m
[32m+[m[32m        if readonly is None:[m
[32m+[m[32m            readonly = False[m
[32m+[m[32m        prefix = ""[m
[32m+[m[32m        typecode = ""[m
[32m+[m[32m        i = 0[m
[32m+[m[32m        if i < len(format):[m
[32m+[m[32m            try:[m
[32m+[m[32m                prefix = self.prefixes[format[i]][m
[32m+[m[32m                i += 1[m
[32m+[m[32m            except LookupError:[m
[32m+[m[32m                pass[m
[32m+[m[32m        if i < len(format) and format[i] == "1":[m
[32m+[m[32m            i += 1[m
[32m+[m[32m        if i == len(format) - 1:[m
[32m+[m[32m            typecode = format[i][m
[32m+[m[32m        if itemsize is None:[m
[32m+[m[32m            try:[m
[32m+[m[32m                itemsize = ctypes.sizeof(self.types[prefix + typecode])[m
[32m+[m[32m            except KeyError:[m
[32m+[m[32m                raise ValueError("Unknown item format '" + format + "'")[m
[32m+[m[32m        self.readonly = bool(readonly)[m
[32m+[m[32m        self.format = format[m
[32m+[m[32m        self._format = ctypes.create_string_buffer(format.encode("latin_1"))[m
[32m+[m[32m        self.ndim = len(shape)[m
[32m+[m[32m        self.itemsize = itemsize[m
[32m+[m[32m        self.len = reduce(operator.mul, shape, 1) * self.itemsize[m
[32m+[m[32m        self.shape = tuple(shape)[m
[32m+[m[32m        self._shape = (ctypes.c_ssize_t * self.ndim)(*self.shape)[m
[32m+[m[32m        if strides is None:[m
[32m+[m[32m            self._strides = (ctypes.c_ssize_t * self.ndim)()[m
[32m+[m[32m            self._strides[self.ndim - 1] = itemsize[m
[32m+[m[32m            for i in range(self.ndim - 1, 0, -1):[m
[32m+[m[32m                self._strides[i - 1] = self.shape[i] * self._strides[i][m
[32m+[m[32m            self.strides = tuple(self._strides)[m
[32m+[m[32m        elif len(strides) == self.ndim:[m
[32m+[m[32m            self.strides = tuple(strides)[m
[32m+[m[32m            self._strides = (ctypes.c_ssize_t * self.ndim)(*self.strides)[m
[32m+[m[32m        else:[m
[32m+[m[32m            raise ValueError("Mismatch in length of strides and shape")[m
[32m+[m[32m        buflen = max(d * abs(s) for d, s in zip(self.shape, self.strides))[m
[32m+[m[32m        self.buflen = buflen[m
[32m+[m[32m        self._buf = (ctypes.c_ubyte * buflen)()[m
[32m+[m[32m        offset = sum([m
[32m+[m[32m            (d - 1) * abs(s) for d, s in zip(self.shape, self.strides) if s < 0[m
[32m+[m[32m        )[m
[32m+[m[32m        self.buf = ctypes.addressof(self._buf) + offset[m
[32m+[m
[32m+[m[32m    def buffer_info(self):[m
[32m+[m[32m        return (ctypes.addressof(self.buffer), self.shape[0])[m
[32m+[m
[32m+[m[32m    def tobytes(self):[m
[32m+[m[32m        return ctypes.cast(self.buffer, ctypes.POINTER(ctypes.c_char))[0 : self._len][m
[32m+[m
[32m+[m[32m    def __len__(self):[m
[32m+[m[32m        return self.shape[0][m
[32m+[m
[32m+[m[32m    def _get_buffer(self, view, flags):[m
[32m+[m[32m        from ctypes import addressof[m
[32m+[m
[32m+[m[32m        if (flags & PyBUF_WRITABLE) == PyBUF_WRITABLE and self.readonly:[m
[32m+[m[32m            raise BufferError("buffer is read-only")[m
[32m+[m[32m        if ([m
[32m+[m[32m            flags & PyBUF_C_CONTIGUOUS[m
[32m+[m[32m        ) == PyBUF_C_CONTIGUOUS and not self.is_contiguous("C"):[m
[32m+[m[32m            raise BufferError("data is not C contiguous")[m
[32m+[m[32m        if ([m
[32m+[m[32m            flags & PyBUF_F_CONTIGUOUS[m
[32m+[m[32m        ) == PyBUF_F_CONTIGUOUS and not self.is_contiguous("F"):[m
[32m+[m[32m            raise BufferError("data is not F contiguous")[m
[32m+[m[32m        if ([m
[32m+[m[32m            flags & PyBUF_ANY_CONTIGUOUS[m
[32m+[m[32m        ) == PyBUF_ANY_CONTIGUOUS and not self.is_contiguous("A"):[m
[32m+[m[32m            raise BufferError("data is not contiguous")[m
[32m+[m[32m        view.buf = self.buf[m
[32m+[m[32m        view.readonly = self.readonly[m
[32m+[m[32m        view.len = self.len[m
[32m+[m[32m        if flags | PyBUF_WRITABLE == PyBUF_WRITABLE:[m
[32m+[m[32m            view.ndim = 0[m
[32m+[m[32m        else:[m
[32m+[m[32m            view.ndim = self.ndim[m
[32m+[m[32m        view.itemsize = self.itemsize[m
[32m+[m[32m        if (flags & PyBUF_FORMAT) == PyBUF_FORMAT:[m
[32m+[m[32m            view.format = addressof(self._format)[m
[32m+[m[32m        else:[m
[32m+[m[32m            view.format = None[m
[32m+[m[32m        if (flags & PyBUF_ND) == PyBUF_ND:[m
[32m+[m[32m            view.shape = addressof(self._shape)[m
[32m+[m[32m        elif self.is_contiguous("C"):[m
[32m+[m[32m            view.shape = None[m
[32m+[m[32m        else:[m
[32m+[m[32m            raise BufferError(f"shape required for {self.ndim} dimensional data")[m
[32m+[m[32m        if (flags & PyBUF_STRIDES) == PyBUF_STRIDES:[m
[32m+[m[32m            view.strides = ctypes.addressof(self._strides)[m
[32m+[m[32m        elif view.shape is None or self.is_contiguous("C"):[m
[32m+[m[32m            view.strides = None[m
[32m+[m[32m        else:[m
[32m+[m[32m            raise BufferError("strides required for none C contiguous data")[m
[32m+[m[32m        view.suboffsets = None[m
[32m+[m[32m        view.internal = None[m
[32m+[m[32m        view.obj = self[m
[32m+[m
[32m+[m[32m    def is_contiguous(self, fortran):[m
[32m+[m[32m        if fortran in "CA":[m
[32m+[m[32m            if self.strides[-1] == self.itemsize:[m
[32m+[m[32m                for i in range(self.ndim - 1, 0, -1):[m
[32m+[m[32m                    if self.strides[i - 1] != self.shape[i] * self.strides[i]:[m
[32m+[m[32m                        break[m
[32m+[m[32m                else:[m
[32m+[m[32m                    return True[m
[32m+[m[32m        if fortran in "FA":[m
[32m+[m[32m            if self.strides[0] == self.itemsize:[m
[32m+[m[32m                for i in range(0, self.ndim - 1):[m
[32m+[m[32m                    if self.strides[i + 1] != self.shape[i] * self.strides[i]:[m
[32m+[m[32m                        break[m
[32m+[m[32m                else:[m
[32m+[m[32m                    return True[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m
[32m+[m[32mclass Importer:[m
[32m+[m[32m    """An object that imports a new buffer interface[m
[32m+[m
[32m+[m[32m    The fields of the Py_buffer C struct are exposed by identically[m
[32m+[m[32m    named Importer read-only properties.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, obj, flags):[m
[32m+[m[32m        self._view = pygame.newbuffer.Py_buffer()[m
[32m+[m[32m        self._view.get_buffer(obj, flags)[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def obj(self):[m
[32m+[m[32m        """return object or None for NULL field"""[m
[32m+[m[32m        return self._view.obj[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def buf(self):[m
[32m+[m[32m        """return int or None for NULL field"""[m
[32m+[m[32m        return self._view.buf[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def len(self):[m
[32m+[m[32m        """return int"""[m
[32m+[m[32m        return self._view.len[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def readonly(self):[m
[32m+[m[32m        """return bool"""[m
[32m+[m[32m        return self._view.readonly[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def format(self):[m
[32m+[m[32m        """return bytes or None for NULL field"""[m
[32m+[m[32m        format_addr = self._view.format[m
[32m+[m[32m        if format_addr is None:[m
[32m+[m[32m            return None[m
[32m+[m[32m        return ctypes.cast(format_addr, ctypes.c_char_p).value.decode("ascii")[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def itemsize(self):[m
[32m+[m[32m        """return int"""[m
[32m+[m[32m        return self._view.itemsize[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def ndim(self):[m
[32m+[m[32m        """return int"""[m
[32m+[m[32m        return self._view.ndim[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def shape(self):[m
[32m+[m[32m        """return int tuple or None for NULL field"""[m
[32m+[m[32m        return self._to_ssize_tuple(self._view.shape)[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def strides(self):[m
[32m+[m[32m        """return int tuple or None for NULL field"""[m
[32m+[m[32m        return self._to_ssize_tuple(self._view.strides)[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def suboffsets(self):[m
[32m+[m[32m        """return int tuple or None for NULL field"""[m
[32m+[m[32m        return self._to_ssize_tuple(self._view.suboffsets)[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def internal(self):[m
[32m+[m[32m        """return int or None for NULL field"""[m
[32m+[m[32m        return self._view.internal[m
[32m+[m
[32m+[m[32m    def _to_ssize_tuple(self, addr):[m
[32m+[m[32m        from ctypes import cast, POINTER, c_ssize_t[m
[32m+[m
[32m+[m[32m        if addr is None:[m
[32m+[m[32m            return None[m
[32m+[m[32m        return tuple(cast(addr, POINTER(c_ssize_t))[0 : self._view.ndim])[m
[32m+[m
[32m+[m
[32m+[m[32mclass ExporterTest(unittest.TestCase):[m
[32m+[m[32m    """Class Exporter unit tests"""[m
[32m+[m
[32m+[m[32m    def test_formats(self):[m
[32m+[m[32m        char_sz = ctypes.sizeof(ctypes.c_char)[m
[32m+[m[32m        short_sz = ctypes.sizeof(ctypes.c_short)[m
[32m+[m[32m        int_sz = ctypes.sizeof(ctypes.c_int)[m
[32m+[m[32m        long_sz = ctypes.sizeof(ctypes.c_long)[m
[32m+[m[32m        longlong_sz = ctypes.sizeof(ctypes.c_longlong)[m
[32m+[m[32m        float_sz = ctypes.sizeof(ctypes.c_float)[m
[32m+[m[32m        double_sz = ctypes.sizeof(ctypes.c_double)[m
[32m+[m[32m        voidp_sz = ctypes.sizeof(ctypes.c_void_p)[m
[32m+[m[32m        bool_sz = ctypes.sizeof(ctypes.c_bool)[m
[32m+[m
[32m+[m[32m        self.check_args(0, (1,), "B", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "b", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "B", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "c", (char_sz,), char_sz, char_sz, char_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "h", (short_sz,), short_sz, short_sz, short_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "H", (short_sz,), short_sz, short_sz, short_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "i", (int_sz,), int_sz, int_sz, int_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "I", (int_sz,), int_sz, int_sz, int_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "l", (long_sz,), long_sz, long_sz, long_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "L", (long_sz,), long_sz, long_sz, long_sz)[m
[32m+[m[32m        self.check_args([m
[32m+[m[32m            1, (1,), "q", (longlong_sz,), longlong_sz, longlong_sz, longlong_sz[m
[32m+[m[32m        )[m
[32m+[m[32m        self.check_args([m
[32m+[m[32m            1, (1,), "Q", (longlong_sz,), longlong_sz, longlong_sz, longlong_sz[m
[32m+[m[32m        )[m
[32m+[m[32m        self.check_args(1, (1,), "f", (float_sz,), float_sz, float_sz, float_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "d", (double_sz,), double_sz, double_sz, double_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "x", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "P", (voidp_sz,), voidp_sz, voidp_sz, voidp_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "?", (bool_sz,), bool_sz, bool_sz, bool_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@b", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "@B", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "@c", (char_sz,), char_sz, char_sz, char_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@h", (short_sz,), short_sz, short_sz, short_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@H", (short_sz,), short_sz, short_sz, short_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@i", (int_sz,), int_sz, int_sz, int_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@I", (int_sz,), int_sz, int_sz, int_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@l", (long_sz,), long_sz, long_sz, long_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@L", (long_sz,), long_sz, long_sz, long_sz)[m
[32m+[m[32m        self.check_args([m
[32m+[m[32m            1, (1,), "@q", (longlong_sz,), longlong_sz, longlong_sz, longlong_sz[m
[32m+[m[32m        )[m
[32m+[m[32m        self.check_args([m
[32m+[m[32m            1, (1,), "@Q", (longlong_sz,), longlong_sz, longlong_sz, longlong_sz[m
[32m+[m[32m        )[m
[32m+[m[32m        self.check_args(1, (1,), "@f", (float_sz,), float_sz, float_sz, float_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@d", (double_sz,), double_sz, double_sz, double_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "@?", (bool_sz,), bool_sz, bool_sz, bool_sz)[m
[32m+[m[32m        self.check_args(1, (1,), "=b", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "=B", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "=c", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "=h", (2,), 2, 2, 2)[m
[32m+[m[32m        self.check_args(1, (1,), "=H", (2,), 2, 2, 2)[m
[32m+[m[32m        self.check_args(1, (1,), "=i", (4,), 4, 4, 4)[m
[32m+[m[32m        self.check_args(1, (1,), "=I", (4,), 4, 4, 4)[m
[32m+[m[32m        self.check_args(1, (1,), "=l", (4,), 4, 4, 4)[m
[32m+[m[32m        self.check_args(1, (1,), "=L", (4,), 4, 4, 4)[m
[32m+[m[32m        self.check_args(1, (1,), "=q", (8,), 8, 8, 8)[m
[32m+[m[32m        self.check_args(1, (1,), "=Q", (8,), 8, 8, 8)[m
[32m+[m[32m        self.check_args(1, (1,), "=?", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "<h", (2,), 2, 2, 2)[m
[32m+[m[32m        self.check_args(1, (1,), ">h", (2,), 2, 2, 2)[m
[32m+[m[32m        self.check_args(1, (1,), "!h", (2,), 2, 2, 2)[m
[32m+[m[32m        self.check_args(1, (1,), "<q", (8,), 8, 8, 8)[m
[32m+[m[32m        self.check_args(1, (1,), ">q", (8,), 8, 8, 8)[m
[32m+[m[32m        self.check_args(1, (1,), "!q", (8,), 8, 8, 8)[m
[32m+[m[32m        self.check_args(1, (1,), "1x", (1,), 1, 1, 1)[m
[32m+[m[32m        self.check_args(1, (1,), "2x", (2,), 2, 2, 2)[m
[32m+[m[32m        self.check_args(1, (1,), "3x", (3,), 3, 3, 3)[m
[32m+[m[32m        self.check_args(1, (1,), "4x", (4,), 4, 4, 4)[m
[32m+[m[32m        self.check_args(1, (1,), "5x", (5,), 5, 5, 5)[m
[32m+[m[32m        self.check_args(1, (1,), "6x", (6,), 6, 6, 6)[m
[32m+[m[32m        self.check_args(1, (1,), "7x", (7,), 7, 7, 7)[m
[32m+[m[32m        self.check_args(1, (1,), "8x", (8,), 8, 8, 8)[m
[32m+[m[32m        self.check_args(1, (1,), "9x", (9,), 9, 9, 9)[m
[32m+[m[32m        self.check_args(1, (1,), "1h", (2,), 2, 2, 2)[m
[32m+[m[32m        self.check_args(1, (1,), "=1h", (2,), 2, 2, 2)[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "W")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "^Q")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "=W")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "=f")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "=d")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "<f")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "<d")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), ">f")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), ">d")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "!f")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "!d")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "0x")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "11x")[m
[32m+[m[32m        self.assertRaises(ValueError, Exporter, (2, 1), "BB")[m
[32m+[m
[32m+[m[32m    def test_strides(self):[m
[32m+[m[32m        self.check_args(1, (10,), "=h", (2,), 20, 20, 2)[m
[32m+[m[32m        self.check_args(1, (5, 3), "=h", (6, 2), 30, 30, 2)[m
[32m+[m[32m        self.check_args(1, (7, 3, 5), "=h", (30, 10, 2), 210, 210, 2)[m
[32m+[m[32m        self.check_args(1, (13, 5, 11, 3), "=h", (330, 66, 6, 2), 4290, 4290, 2)[m
[32m+[m[32m        self.check_args(3, (7, 3, 5), "=h", (2, 14, 42), 210, 210, 2)[m
[32m+[m[32m        self.check_args(3, (7, 3, 5), "=h", (2, 16, 48), 210, 240, 2)[m
[32m+[m[32m        self.check_args(3, (13, 5, 11, 3), "=h", (440, 88, 8, 2), 4290, 5720, 2)[m
[32m+[m[32m        self.check_args(3, (7, 5), "3x", (15, 3), 105, 105, 3)[m
[32m+[m[32m        self.check_args(3, (7, 5), "3x", (3, 21), 105, 105, 3)[m
[32m+[m[32m        self.check_args(3, (7, 5), "3x", (3, 24), 105, 120, 3)[m
[32m+[m
[32m+[m[32m    def test_readonly(self):[m
[32m+[m[32m        a = Exporter((2,), "h", readonly=True)[m
[32m+[m[32m        self.assertTrue(a.readonly)[m
[32m+[m[32m        b = Importer(a, PyBUF_STRIDED_RO)[m
[32m+[m[32m        self.assertRaises(BufferError, Importer, a, PyBUF_STRIDED)[m
[32m+[m[32m        b = Importer(a, PyBUF_STRIDED_RO)[m
[32m+[m
[32m+[m[32m    def test_is_contiguous(self):[m
[32m+[m[32m        a = Exporter((10,), "=h")[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("C"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("F"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        a = Exporter((10, 4), "=h")[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("C"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("F"))[m
[32m+[m[32m        a = Exporter((13, 5, 11, 3), "=h", (330, 66, 6, 2))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("C"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("F"))[m
[32m+[m[32m        a = Exporter((10, 4), "=h", (2, 20))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("F"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("C"))[m
[32m+[m[32m        a = Exporter((13, 5, 11, 3), "=h", (2, 26, 130, 1430))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("F"))[m
[32m+[m[32m        self.assertTrue(a.is_contiguous("A"))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("C"))[m
[32m+[m[32m        a = Exporter((2, 11, 6, 4), "=h", (576, 48, 8, 2))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("A"))[m
[32m+[m[32m        a = Exporter((2, 11, 6, 4), "=h", (2, 4, 48, 288))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("A"))[m
[32m+[m[32m        a = Exporter((3, 2, 2), "=h", (16, 8, 4))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("A"))[m
[32m+[m[32m        a = Exporter((3, 2, 2), "=h", (4, 12, 24))[m
[32m+[m[32m        self.assertFalse(a.is_contiguous("A"))[m
[32m+[m
[32m+[m[32m    def test_PyBUF_flags(self):[m
[32m+[m[32m        a = Exporter((10, 2), "d")[m
[32m+[m[32m        b = Importer(a, PyBUF_SIMPLE)[m
[32m+[m[32m        self.assertTrue(b.obj is a)[m
[32m+[m[32m        self.assertTrue(b.format is None)[m
[32m+[m[32m        self.assertEqual(b.len, a.len)[m
[32m+[m[32m        self.assertEqual(b.itemsize, a.itemsize)[m
[32m+[m[32m        self.assertTrue(b.shape is None)[m
[32m+[m[32m        self.assertTrue(b.strides is None)[m
[32m+[m[32m        self.assertTrue(b.suboffsets is None)[m
[32m+[m[32m        self.assertTrue(b.internal is None)[m
[32m+[m[32m        self.assertFalse(b.readonly)[m
[32m+[m[32m        b = Importer(a, PyBUF_WRITABLE)[m
[32m+[m[32m        self.assertTrue(b.obj is a)[m
[32m+[m[32m        self.assertTrue(b.format is None)[m
[32m+[m[32m        self.assertEqual(b.len, a.len)[m
[32m+[m[32m        self.assertEqual(b.itemsize, a.itemsize)[m
[32m+[m[32m        self.assertTrue(b.shape is None)[m
[32m+[m[32m        self.assertTrue(b.strides is None)[m
[32m+[m[32m        self.assertTrue(b.suboffsets is None)[m
[32m+[m[32m        self.assertTrue(b.internal is None)[m
[32m+[m[32m        self.assertFalse(b.readonly)[m
[32m+[m[32m        b = Importer(a, PyBUF_ND)[m
[32m+[m[32m        self.assertTrue(b.obj is a)[m
[32m+[m[32m        self.assertTrue(b.format is None)[m
[32m+[m[32m        self.assertEqual(b.len, a.len)[m
[32m+[m[32m        self.assertEqual(b.itemsize, a.itemsize)[m
[32m+[m[32m        self.assertEqual(b.shape, a.shape)[m
[32m+[m[32m        self.assertTrue(b.strides is None)[m
[32m+[m[32m        self.assertTrue(b.suboffsets is None)[m
[32m+[m[32m        self.assertTrue(b.internal is None)[m
[32m+[m[32m        self.assertFalse(b.readonly)[m
[32m+[m[32m        a = Exporter((5, 10), "=h", (24, 2))[m
[32m+[m[32m        b = Importer(a, PyBUF_STRIDES)[m
[32m+[m[32m        self.assertTrue(b.obj is a)[m
[32m+[m[32m        self.assertTrue(b.format is None)[m
[32m+[m[32m        self.assertEqual(b.len, a.len)[m
[32m+[m[32m        self.assertEqual(b.itemsize, a.itemsize)[m
[32m+[m[32m        self.assertEqual(b.shape, a.shape)[m
[32m+[m[32m        self.assertEqual(b.strides, a.strides)[m
[32m+[m[32m        self.assertTrue(b.suboffsets is None)[m
[32m+[m[32m        self.assertTrue(b.internal is None)[m
[32m+[m[32m        self.assertFalse(b.readonly)[m
[32m+[m[32m        b = Importer(a, PyBUF_FULL)[m
[32m+[m[32m        self.assertTrue(b.obj is a)[m
[32m+[m[32m        self.assertEqual(b.format, "=h")[m
[32m+[m[32m        self.assertEqual(b.len, a.len)[m
[32m+[m[32m        self.assertEqual(b.itemsize, a.itemsize)[m
[32m+[m[32m        self.assertEqual(b.shape, a.shape)[m
[32m+[m[32m        self.assertEqual(b.strides, a.strides)[m
[32m+[m[32m        self.assertTrue(b.suboffsets is None)[m
[32m+[m[32m        self.assertTrue(b.internal is None)[m
[32m+[m[32m        self.assertFalse(b.readonly)[m
[32m+[m[32m        self.assertRaises(BufferError, Importer, a, PyBUF_SIMPLE)[m
[32m+[m[32m        self.assertRaises(BufferError, Importer, a, PyBUF_WRITABLE)[m
[32m+[m[32m        self.assertRaises(BufferError, Importer, a, PyBUF_ND)[m
[32m+[m[32m        self.assertRaises(BufferError, Importer, a, PyBUF_C_CONTIGUOUS)[m
[32m+[m[32m        self.assertRaises(BufferError, Importer, a, PyBUF_F_CONTIGUOUS)[m
[32m+[m[32m        self.assertRaises(BufferError, Importer, a, PyBUF_ANY_CONTIGUOUS)[m
[32m+[m[32m        self.assertRaises(BufferError, Importer, a, PyBUF_CONTIG)[m
[32m+[m
[32m+[m[32m    def test_negative_strides(self):[m
[32m+[m[32m        self.check_args(3, (3, 5, 4), "B", (20, 4, -1), 60, 60, 1, 3)[m
[32m+[m[32m        self.check_args(3, (3, 5, 3), "B", (20, 4, -1), 45, 60, 1, 2)[m
[32m+[m[32m        self.check_args(3, (3, 5, 4), "B", (20, -4, 1), 60, 60, 1, 16)[m
[32m+[m[32m        self.check_args(3, (3, 5, 4), "B", (-20, -4, -1), 60, 60, 1, 59)[m
[32m+[m[32m        self.check_args(3, (3, 5, 3), "B", (-20, -4, -1), 45, 60, 1, 58)[m
[32m+[m
[32m+[m[32m    def test_attributes(self):[m
[32m+[m[32m        a = Exporter((13, 5, 11, 3), "=h", (440, 88, 8, 2))[m
[32m+[m[32m        self.assertEqual(a.ndim, 4)[m
[32m+[m[32m        self.assertEqual(a.itemsize, 2)[m
[32m+[m[32m        self.assertFalse(a.readonly)[m
[32m+[m[32m        self.assertEqual(a.shape, (13, 5, 11, 3))[m
[32m+[m[32m        self.assertEqual(a.format, "=h")[m
[32m+[m[32m        self.assertEqual(a.strides, (440, 88, 8, 2))[m
[32m+[m[32m        self.assertEqual(a.len, 4290)[m
[32m+[m[32m        self.assertEqual(a.buflen, 5720)[m
[32m+[m[32m        self.assertEqual(a.buf, ctypes.addressof(a._buf))[m
[32m+[m[32m        a = Exporter((8,))[m
[32m+[m[32m        self.assertEqual(a.ndim, 1)[m
[32m+[m[32m        self.assertEqual(a.itemsize, 1)[m
[32m+[m[32m        self.assertFalse(a.readonly)[m
[32m+[m[32m        self.assertEqual(a.shape, (8,))[m
[32m+[m[32m        self.assertEqual(a.format, "B")[m
[32m+[m[32m        self.assertTrue(isinstance(a.strides, tuple))[m
[32m+[m[32m        self.assertEqual(a.strides, (1,))[m
[32m+[m[32m        self.assertEqual(a.len, 8)[m
[32m+[m[32m        self.assertEqual(a.buflen, 8)[m
[32m+[m[32m        a = Exporter([13, 5, 11, 3], "=h", [440, 88, 8, 2])[m
[32m+[m[32m        self.assertTrue(isinstance(a.shape, tuple))[m
[32m+[m[32m        self.assertTrue(isinstance(a.strides, tuple))[m
[32m+[m[32m        self.assertEqual(a.shape, (13, 5, 11, 3))[m
[32m+[m[32m        self.assertEqual(a.strides, (440, 88, 8, 2))[m
[32m+[m
[32m+[m[32m    def test_itemsize(self):[m
[32m+[m[32m        exp = Exporter((4, 5), format="B", itemsize=8)[m
[32m+[m[32m        imp = Importer(exp, PyBUF_RECORDS)[m
[32m+[m[32m        self.assertEqual(imp.itemsize, 8)[m
[32m+[m[32m        self.assertEqual(imp.format, "B")[m
[32m+[m[32m        self.assertEqual(imp.strides, (40, 8))[m
[32m+[m[32m        exp = Exporter((4, 5), format="weird", itemsize=5)[m
[32m+[m[32m        imp = Importer(exp, PyBUF_RECORDS)[m
[32m+[m[32m        self.assertEqual(imp.itemsize, 5)[m
[32m+[m[32m        self.assertEqual(imp.format, "weird")[m
[32m+[m[32m        self.assertEqual(imp.strides, (25, 5))[m
[32m+[m
[32m+[m[32m    def check_args([m
[32m+[m[32m        self, call_flags, shape, format, strides, length, bufsize, itemsize, offset=0[m
[32m+[m[32m    ):[m
[32m+[m[32m        format_arg = format if call_flags & 1 else None[m
[32m+[m[32m        strides_arg = strides if call_flags & 2 else None[m
[32m+[m[32m        a = Exporter(shape, format_arg, strides_arg)[m
[32m+[m[32m        self.assertEqual(a.buflen, bufsize)[m
[32m+[m[32m        self.assertEqual(a.buf, ctypes.addressof(a._buf) + offset)[m
[32m+[m[32m        m = Importer(a, PyBUF_RECORDS_RO)[m
[32m+[m[32m        self.assertEqual(m.buf, a.buf)[m
[32m+[m[32m        self.assertEqual(m.len, length)[m
[32m+[m[32m        self.assertEqual(m.format, format)[m
[32m+[m[32m        self.assertEqual(m.itemsize, itemsize)[m
[32m+[m[32m        self.assertEqual(m.shape, shape)[m
[32m+[m[32m        self.assertEqual(m.strides, strides)[m
[32m+[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    unittest.main()[m
[1mdiff --git a/pygame/tests/test_utils/endian.py b/pygame/tests/test_utils/endian.py[m
[1mnew file mode 100644[m
[1mindex 00000000..64ba1b32[m
[1m--- /dev/null[m
[1m+++ b/pygame/tests/test_utils/endian.py[m
[36m@@ -0,0 +1,20 @@[m
[32m+[m[32m# Module pygame.tests.test_utils.endian[m
[32m+[m[32m#[m
[32m+[m[32m# Machine independent conversion to little-endian and big-endian Python[m
[32m+[m[32m# integer values.[m
[32m+[m
[32m+[m[32mimport struct[m
[32m+[m
[32m+[m
[32m+[m[32mdef little_endian_uint32(i):[m
[32m+[m[32m    """Return the 32 bit unsigned integer little-endian representation of i"""[m
[32m+[m
[32m+[m[32m    s = struct.pack("<I", i)[m
[32m+[m[32m    return struct.unpack("=I", s)[0][m
[32m+[m
[32m+[m
[32m+[m[32mdef big_endian_uint32(i):[m
[32m+[m[32m    """Return the 32 bit unsigned integer big-endian representation of i"""[m
[32m+[m
[32m+[m[32m    s = struct.pack(">I", i)[m
[32m+[m[32m    return struct.unpack("=I", s)[0][m
[1mdiff --git a/pygame/tests/test_utils/png.py b/pygame/tests/test_utils/png.py[m
[1mnew file mode 100644[m
[1mindex 00000000..5d055ea4[m
[1m--- /dev/null[m
[1m+++ b/pygame/tests/test_utils/png.py[m
[36m@@ -0,0 +1,4005 @@[m
[32m+[m[32m#!/usr/bin/env python[m
[32m+[m
[32m+[m[32m# $URL: http://pypng.googlecode.com/svn/trunk/code/png.py $[m
[32m+[m[32m# $Rev: 228 $[m
[32m+[m
[32m+[m[32m# png.py - PNG encoder/decoder in pure Python[m
[32m+[m[32m#[m
[32m+[m[32m# Modified for Pygame in Oct., 2012 to work with Python 3.x.[m
[32m+[m[32m#[m
[32m+[m[32m# Copyright (C) 2006 Johann C. Rocholl <johann@browsershots.org>[m
[32m+[m[32m# Portions Copyright (C) 2009 David Jones <drj@pobox.com>[m
[32m+[m[32m# And probably portions Copyright (C) 2006 Nicko van Someren <nicko@nicko.org>[m
[32m+[m[32m#[m
[32m+[m[32m# Original concept by Johann C. Rocholl.[m
[32m+[m[32m#[m
[32m+[m[32m# LICENSE (The MIT License)[m
[32m+[m[32m#[m
[32m+[m[32m# Permission is hereby granted, free of charge, to any person[m
[32m+[m[32m# obtaining a copy of this software and associated documentation files[m
[32m+[m[32m# (the "Software"), to deal in the Software without restriction,[m
[32m+[m[32m# including without limitation the rights to use, copy, modify, merge,[m
[32m+[m[32m# publish, distribute, sublicense, and/or sell copies of the Software,[m
[32m+[m[32m# and to permit persons to whom the Software is furnished to do so,[m
[32m+[m[32m# subject to the following conditions:[m
[32m+[m[32m#[m
[32m+[m[32m# The above copyright notice and this permission notice shall be[m
[32m+[m[32m# included in all copies or substantial portions of the Software.[m
[32m+[m[32m#[m
[32m+[m[32m# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,[m
[32m+[m[32m# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[32m+[m[32m# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND[m
[32m+[m[32m# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS[m
[32m+[m[32m# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN[m
[32m+[m[32m# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN[m
[32m+[m[32m# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE[m
[32m+[m[32m# SOFTWARE.[m
[32m+[m[32m#[m
[32m+[m[32m# Changelog (recent first):[m
[32m+[m[32m# 2009-03-11 David: interlaced bit depth < 8 (writing).[m
[32m+[m[32m# 2009-03-10 David: interlaced bit depth < 8 (reading).[m
[32m+[m[32m# 2009-03-04 David: Flat and Boxed pixel formats.[m
[32m+[m[32m# 2009-02-26 David: Palette support (writing).[m
[32m+[m[32m# 2009-02-23 David: Bit-depths < 8; better PNM support.[m
[32m+[m[32m# 2006-06-17 Nicko: Reworked into a class, faster interlacing.[m
[32m+[m[32m# 2006-06-17 Johann: Very simple prototype PNG decoder.[m
[32m+[m[32m# 2006-06-17 Nicko: Test suite with various image generators.[m
[32m+[m[32m# 2006-06-17 Nicko: Alpha-channel, grey-scale, 16-bit/plane support.[m
[32m+[m[32m# 2006-06-15 Johann: Scanline iterator interface for large input files.[m
[32m+[m[32m# 2006-06-09 Johann: Very simple prototype PNG encoder.[m
[32m+[m
[32m+[m[32m# Incorporated into Bangai-O Development Tools by drj on 2009-02-11 from[m
[32m+[m[32m# http://trac.browsershots.org/browser/trunk/pypng/lib/png.py?rev=2885[m
[32m+[m
[32m+[m[32m# Incorporated into pypng by drj on 2009-03-12 from[m
[32m+[m[32m# //depot/prj/bangaio/master/code/png.py#67[m
[32m+[m
[32m+[m
[32m+[m[32m"""[m
[32m+[m[32mPure Python PNG Reader/Writer[m
[32m+[m
[32m+[m[32mThis Python module implements support for PNG images (see PNG[m
[32m+[m[32mspecification at http://www.w3.org/TR/2003/REC-PNG-20031110/ ). It reads[m
[32m+[m[32mand writes PNG files with all allowable bit depths (1/2/4/8/16/24/32/48/64[m
[32m+[m[32mbits per pixel) and colour combinations: greyscale (1/2/4/8/16 bit); RGB,[m
[32m+[m[32mRGBA, LA (greyscale with alpha) with 8/16 bits per channel; colour mapped[m
[32m+[m[32mimages (1/2/4/8 bit).  Adam7 interlacing is supported for reading and[m
[32m+[m[32mwriting.  A number of optional chunks can be specified (when writing)[m
[32m+[m[32mand understood (when reading): ``tRNS``, ``bKGD``, ``gAMA``.[m
[32m+[m
[32m+[m[32mFor help, type ``import png; help(png)`` in your python interpreter.[m
[32m+[m
[32m+[m[32mA good place to start is the :class:`Reader` and :class:`Writer` classes.[m
[32m+[m
[32m+[m[32mThis file can also be used as a command-line utility to convert[m
[32m+[m[32m`Netpbm <http://netpbm.sourceforge.net/>`_ PNM files to PNG, and the reverse conversion from PNG to[m
[32m+[m[32mPNM. The interface is similar to that of the ``pnmtopng`` program from[m
[32m+[m[32mNetpbm.  Type ``python png.py --help`` at the shell prompt[m
[32m+[m[32mfor usage and a list of options.[m
[32m+[m
[32m+[m[32mA note on spelling and terminology[m
[32m+[m[32m----------------------------------[m
[32m+[m
[32m+[m[32mGenerally British English spelling is used in the documentation.  So[m
[32m+[m[32mthat's "greyscale" and "colour".  This not only matches the author's[m
[32m+[m[32mnative language, it's also used by the PNG specification.[m
[32m+[m
[32m+[m[32mThe major colour models supported by PNG (and hence by PyPNG) are:[m
[32m+[m[32mgreyscale, RGB, greyscale--alpha, RGB--alpha.  These are sometimes[m
[32m+[m[32mreferred to using the abbreviations: L, RGB, LA, RGBA.  In this case[m
[32m+[m[32meach letter abbreviates a single channel: *L* is for Luminance or Luma or[m
[32m+[m[32mLightness which is the channel used in greyscale images; *R*, *G*, *B* stand[m
[32m+[m[32mfor Red, Green, Blue, the components of a colour image; *A* stands for[m
[32m+[m[32mAlpha, the opacity channel (used for transparency effects, but higher[m
[32m+[m[32mvalues are more opaque, so it makes sense to call it opacity).[m
[32m+[m
[32m+[m[32mA note on formats[m
[32m+[m[32m-----------------[m
[32m+[m
[32m+[m[32mWhen getting pixel data out of this module (reading) and presenting[m
[32m+[m[32mdata to this module (writing) there are a number of ways the data could[m
[32m+[m[32mbe represented as a Python value.  Generally this module uses one of[m
[32m+[m[32mthree formats called "flat row flat pixel", "boxed row flat pixel", and[m
[32m+[m[32m"boxed row boxed pixel".  Basically the concern is whether each pixel[m
[32m+[m[32mand each row comes in its own little tuple (box), or not.[m
[32m+[m
[32m+[m[32mConsider an image that is 3 pixels wide by 2 pixels high, and each pixel[m
[32m+[m[32mhas RGB components:[m
[32m+[m
[32m+[m[32mBoxed row flat pixel::[m
[32m+[m
[32m+[m[32m  list([R,G,B, R,G,B, R,G,B],[m
[32m+[m[32m       [R,G,B, R,G,B, R,G,B])[m
[32m+[m
[32m+[m[32mEach row appears as its own list, but the pixels are flattened so that[m
[32m+[m[32mthree values for one pixel simply follow the three values for the previous[m
[32m+[m[32mpixel.  This is the most common format used, because it provides a good[m
[32m+[m[32mcompromise between space and convenience.  PyPNG regards itself as[m
[32m+[m[32mat liberty to replace any sequence type with any sufficiently compatible[m
[32m+[m[32mother sequence type; in practice each row is an array (from the array[m
[32m+[m[32mmodule), and the outer list is sometimes an iterator rather than an[m
[32m+[m[32mexplicit list (so that streaming is possible).[m
[32m+[m
[32m+[m[32mFlat row flat pixel::[m
[32m+[m
[32m+[m[32m  [R,G,B, R,G,B, R,G,B,[m
[32m+[m[32m   R,G,B, R,G,B, R,G,B][m
[32m+[m
[32m+[m[32mThe entire image is one single giant sequence of colour values.[m
[32m+[m[32mGenerally an array will be used (to save space), not a list.[m
[32m+[m
[32m+[m[32mBoxed row boxed pixel::[m
[32m+[m
[32m+[m[32m  list([ (R,G,B), (R,G,B), (R,G,B) ],[m
[32m+[m[32m       [ (R,G,B), (R,G,B), (R,G,B) ])[m
[32m+[m
[32m+[m[32mEach row appears in its own list, but each pixel also appears in its own[m
[32m+[m[32mtuple.  A serious memory burn in Python.[m
[32m+[m
[32m+[m[32mIn all cases the top row comes first, and for each row the pixels are[m
[32m+[m[32mordered from left-to-right.  Within a pixel the values appear in the[m
[32m+[m[32morder, R-G-B-A (or L-A for greyscale--alpha).[m
[32m+[m
[32m+[m[32mThere is a fourth format, mentioned because it is used internally,[m
[32m+[m[32mis close to what lies inside a PNG file itself, and has some support[m
[32m+[m[32mfrom the public API.  This format is called packed.  When packed,[m
[32m+[m[32meach row is a sequence of bytes (integers from 0 to 255), just as[m
[32m+[m[32mit is before PNG scanline filtering is applied.  When the bit depth[m
[32m+[m[32mis 8 this is essentially the same as boxed row flat pixel; when the[m
[32m+[m[32mbit depth is less than 8, several pixels are packed into each byte;[m
[32m+[m[32mwhen the bit depth is 16 (the only value more than 8 that is supported[m
[32m+[m[32mby the PNG image format) each pixel value is decomposed into 2 bytes[m
[32m+[m[32m(and `packed` is a misnomer).  This format is used by the[m
[32m+[m[32m:meth:`Writer.write_packed` method.  It isn't usually a convenient[m
[32m+[m[32mformat, but may be just right if the source data for the PNG image[m
[32m+[m[32mcomes from something that uses a similar format (for example, 1-bit[m
[32m+[m[32mBMPs, or another PNG file).[m
[32m+[m
[32m+[m[32mAnd now, my famous members[m
[32m+[m[32m--------------------------[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32m__version__ = "$URL: http://pypng.googlecode.com/svn/trunk/code/png.py $ $Rev: 228 $"[m
[32m+[m
[32m+[m[32mimport io[m
[32m+[m[32mimport itertools[m
[32m+[m[32mimport math[m
[32m+[m[32mimport operator[m
[32m+[m[32mimport struct[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport zlib[m
[32m+[m[32mimport warnings[m
[32m+[m[32mfrom array import array[m
[32m+[m[32mfrom functools import reduce[m
[32m+[m
[32m+[m[32mfrom pygame.tests.test_utils import tostring[m
[32m+[m
[32m+[m[32m__all__ = ["Image", "Reader", "Writer", "write_chunks", "from_array"][m
[32m+[m
[32m+[m
[32m+[m[32m# The PNG signature.[m
[32m+[m[32m# http://www.w3.org/TR/PNG/#5PNG-file-signature[m
[32m+[m[32m_signature = struct.pack("8B", 137, 80, 78, 71, 13, 10, 26, 10)[m
[32m+[m
[32m+[m[32m_adam7 = ([m
[32m+[m[32m    (0, 0, 8, 8),[m
[32m+[m[32m    (4, 0, 8, 8),[m
[32m+[m[32m    (0, 4, 4, 8),[m
[32m+[m[32m    (2, 0, 4, 4),[m
[32m+[m[32m    (0, 2, 2, 4),[m
[32m+[m[32m    (1, 0, 2, 2),[m
[32m+[m[32m    (0, 1, 1, 2),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef group(s, n):[m
[32m+[m[32m    # See[m
[32m+[m[32m    # http://www.python.org/doc/2.6/library/functions.html#zip[m
[32m+[m[32m    return zip(*[iter(s)] * n)[m
[32m+[m
[32m+[m
[32m+[m[32mdef isarray(x):[m
[32m+[m[32m    """Same as ``isinstance(x, array)``."""[m
[32m+[m[32m    return isinstance(x, array)[m
[32m+[m
[32m+[m
[32m+[m[32m# Conditionally convert to bytes.  Works on Python 2 and Python 3.[m
[32m+[m[32mtry:[m
[32m+[m[32m    bytes("", "ascii")[m
[32m+[m
[32m+[m[32m    def strtobytes(x):[m
[32m+[m[32m        return bytes(x, "iso8859-1")[m
[32m+[m
[32m+[m[32m    def bytestostr(x):[m
[32m+[m[32m        return str(x, "iso8859-1")[m
[32m+[m
[32m+[m[32mexcept:[m
[32m+[m[32m    strtobytes = str[m
[32m+[m[32m    bytestostr = str[m
[32m+[m
[32m+[m
[32m+[m[32mdef interleave_planes(ipixels, apixels, ipsize, apsize):[m
[32m+[m[32m    """[m
[32m+[m[32m    Interleave (colour) planes, e.g. RGB + A = RGBA.[m
[32m+[m
[32m+[m[32m    Return an array of pixels consisting of the `ipsize` elements of data[m
[32m+[m[32m    from each pixel in `ipixels` followed by the `apsize` elements of data[m
[32m+[m[32m    from each pixel in `apixels`.  Conventionally `ipixels` and[m
[32m+[m[32m    `apixels` are byte arrays so the sizes are bytes, but it actually[m
[32m+[m[32m    works with any arrays of the same type.  The returned array is the[m
[32m+[m[32m    same type as the input arrays which should be the same type as each other.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    itotal = len(ipixels)[m
[32m+[m[32m    atotal = len(apixels)[m
[32m+[m[32m    newtotal = itotal + atotal[m
[32m+[m[32m    newpsize = ipsize + apsize[m
[32m+[m[32m    # Set up the output buffer[m
[32m+[m[32m    # See http://www.python.org/doc/2.4.4/lib/module-array.html#l2h-1356[m
[32m+[m[32m    out = array(ipixels.typecode)[m
[32m+[m[32m    # It's annoying that there is no cheap way to set the array size :-([m
[32m+[m[32m    out.extend(ipixels)[m
[32m+[m[32m    out.extend(apixels)[m
[32m+[m[32m    # Interleave in the pixel data[m
[32m+[m[32m    for i in range(ipsize):[m
[32m+[m[32m        out[i:newtotal:newpsize] = ipixels[i:itotal:ipsize][m
[32m+[m[32m    for i in range(apsize):[m
[32m+[m[32m        out[i + ipsize : newtotal : newpsize] = apixels[i:atotal:apsize][m
[32m+[m[32m    return out[m
[32m+[m
[32m+[m
[32m+[m[32mdef check_palette(palette):[m
[32m+[m[32m    """Check a palette argument (to the :class:`Writer` class) for validity.[m
[32m+[m[32m    Returns the palette as a list if okay; raises an exception otherwise.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    # None is the default and is allowed.[m
[32m+[m[32m    if palette is None:[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m[32m    p = list(palette)[m
[32m+[m[32m    if not (0 < len(p) <= 256):[m
[32m+[m[32m        raise ValueError("a palette must have between 1 and 256 entries")[m
[32m+[m[32m    seen_triple = False[m
[32m+[m[32m    for i, t in enumerate(p):[m
[32m+[m[32m        if len(t) not in (3, 4):[m
[32m+[m[32m            raise ValueError("palette entry %d: entries must be 3- or 4-tuples." % i)[m
[32m+[m[32m        if len(t) == 3:[m
[32m+[m[32m            seen_triple = True[m
[32m+[m[32m        if seen_triple and len(t) == 4:[m
[32m+[m[32m            raise ValueError([m
[32m+[m[32m                "palette entry %d: all 4-tuples must precede all 3-tuples" % i[m
[32m+[m[32m            )[m
[32m+[m[32m        for x in t:[m
[32m+[m[32m            if int(x) != x or not (0 <= x <= 255):[m
[32m+[m[32m                raise ValueError([m
[32m+[m[32m                    "palette entry %d: values must be integer: 0 <= x <= 255" % i[m
[32m+[m[32m                )[m
[32m+[m[32m    return p[m
[32m+[m
[32m+[m
[32m+[m[32mclass Error(Exception):[m
[32m+[m[32m    prefix = "Error"[m
[32m+[m
[32m+[m[32m    def __str__(self):[m
[32m+[m[32m        return f'{self.prefix}: {" ".join(self.args)}'[m
[32m+[m
[32m+[m
[32m+[m[32mclass FormatError(Error):[m
[32m+[m[32m    """Problem with input file format.  In other words, PNG file does[m
[32m+[m[32m    not conform to the specification in some way and is invalid.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    prefix = "FormatError"[m
[32m+[m
[32m+[m
[32m+[m[32mclass ChunkError(FormatError):[m
[32m+[m[32m    prefix = "ChunkError"[m
[32m+[m
[32m+[m
[32m+[m[32mclass Writer:[m
[32m+[m[32m    """[m
[32m+[m[32m    PNG encoder in pure Python.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__([m
[32m+[m[32m        self,[m
[32m+[m[32m        width=None,[m
[32m+[m[32m        height=None,[m
[32m+[m[32m        size=None,[m
[32m+[m[32m        greyscale=False,[m
[32m+[m[32m        alpha=False,[m
[32m+[m[32m        bitdepth=8,[m
[32m+[m[32m        palette=None,[m
[32m+[m[32m        transparent=None,[m
[32m+[m[32m        background=None,[m
[32m+[m[32m        gamma=None,[m
[32m+[m[32m        compression=None,[m
[32m+[m[32m        interlace=False,[m
[32m+[m[32m        bytes_per_sample=None,  # deprecated[m
[32m+[m[32m        planes=None,[m
[32m+[m[32m        colormap=None,[m
[32m+[m[32m        maxval=None,[m
[32m+[m[32m        chunk_limit=2**20,[m
[32m+[m[32m    ):[m
[32m+[m[32m        """[m
[32m+[m[32m        Create a PNG encoder object.[m
[32m+[m
[32m+[m[32m        Arguments:[m
[32m+[m
[32m+[m[32m        width, height[m
[32m+[m[32m          Image size in pixels, as two separate arguments.[m
[32m+[m[32m        size[m
[32m+[m[32m          Image size (w,h) in pixels, as single argument.[m
[32m+[m[32m        greyscale[m
[32m+[m[32m          Input data is greyscale, not RGB.[m
[32m+[m[32m        alpha[m
[32m+[m[32m          Input data has alpha channel (RGBA or LA).[m
[32m+[m[32m        bitdepth[m
[32m+[m[32m          Bit depth: from 1 to 16.[m
[32m+[m[32m        palette[m
[32m+[m[32m          Create a palette for a colour mapped image (colour type 3).[m
[32m+[m[32m        transparent[m
[32m+[m[32m          Specify a transparent colour (create a ``tRNS`` chunk).[m
[32m+[m[32m        background[m
[32m+[m[32m          Specify a default background colour (create a ``bKGD`` chunk).[m
[32m+[m[32m        gamma[m
[32m+[m[32m          Specify a gamma value (create a ``gAMA`` chunk).[m
[32m+[m[32m        compression[m
[32m+[m[32m          zlib compression level (1-9).[m
[32m+[m[32m        interlace[m
[32m+[m[32m          Create an interlaced image.[m
[32m+[m[32m        chunk_limit[m
[32m+[m[32m          Write multiple ``IDAT`` chunks to save memory.[m
[32m+[m
[32m+[m[32m        The image size (in pixels) can be specified either by using the[m
[32m+[m[32m        `width` and `height` arguments, or with the single `size`[m
[32m+[m[32m        argument.  If `size` is used it should be a pair (*width*,[m
[32m+[m[32m        *height*).[m
[32m+[m
[32m+[m[32m        `greyscale` and `alpha` are booleans that specify whether[m
[32m+[m[32m        an image is greyscale (or colour), and whether it has an[m
[32m+[m[32m        alpha channel (or not).[m
[32m+[m
[32m+[m[32m        `bitdepth` specifies the bit depth of the source pixel values.[m
[32m+[m[32m        Each source pixel value must be an integer between 0 and[m
[32m+[m[32m        ``2**bitdepth-1``.  For example, 8-bit images have values[m
[32m+[m[32m        between 0 and 255.  PNG only stores images with bit depths of[m
[32m+[m[32m        1,2,4,8, or 16.  When `bitdepth` is not one of these values,[m
[32m+[m[32m        the next highest valid bit depth is selected, and an ``sBIT``[m
[32m+[m[32m        (significant bits) chunk is generated that specifies the original[m
[32m+[m[32m        precision of the source image.  In this case the supplied pixel[m
[32m+[m[32m        values will be rescaled to fit the range of the selected bit depth.[m
[32m+[m
[32m+[m[32m        The details of which bit depth / colour model combinations the[m
[32m+[m[32m        PNG file format supports directly, are somewhat arcane[m
[32m+[m[32m        (refer to the PNG specification for full details).  Briefly:[m
[32m+[m[32m        "small" bit depths (1,2,4) are only allowed with greyscale and[m
[32m+[m[32m        colour mapped images; colour mapped images cannot have bit depth[m
[32m+[m[32m        16.[m
[32m+[m
[32m+[m[32m        For colour mapped images (in other words, when the `palette`[m
[32m+[m[32m        argument is specified) the `bitdepth` argument must match one of[m
[32m+[m[32m        the valid PNG bit depths: 1, 2, 4, or 8.  (It is valid to have a[m
[32m+[m[32m        PNG image with a palette and an ``sBIT`` chunk, but the meaning[m
[32m+[m[32m        is slightly different; it would be awkward to press the[m
[32m+[m[32m        `bitdepth` argument into service for this.)[m
[32m+[m
[32m+[m[32m        The `palette` option, when specified, causes a colour mapped image[m
[32m+[m[32m        to be created: the PNG colour type is set to 3; greyscale[m
[32m+[m[32m        must not be set; alpha must not be set; transparent must[m
[32m+[m[32m        not be set; the bit depth must be 1,2,4, or 8.  When a colour[m
[32m+[m[32m        mapped image is created, the pixel values are palette indexes[m
[32m+[m[32m        and the `bitdepth` argument specifies the size of these indexes[m
[32m+[m[32m        (not the size of the colour values in the palette).[m
[32m+[m
[32m+[m[32m        The palette argument value should be a sequence of 3- or[m
[32m+[m[32m        4-tuples.  3-tuples specify RGB palette entries; 4-tuples[m
[32m+[m[32m        specify RGBA palette entries.  If both 4-tuples and 3-tuples[m
[32m+[m[32m        appear in the sequence then all the 4-tuples must come[m
[32m+[m[32m        before all the 3-tuples.  A ``PLTE`` chunk is created; if there[m
[32m+[m[32m        are 4-tuples then a ``tRNS`` chunk is created as well.  The[m
[32m+[m[32m        ``PLTE`` chunk will contain all the RGB triples in the same[m
[32m+[m[32m        sequence; the ``tRNS`` chunk will contain the alpha channel for[m
[32m+[m[32m        all the 4-tuples, in the same sequence.  Palette entries[m
[32m+[m[32m        are always 8-bit.[m
[32m+[m
[32m+[m[32m        If specified, the `transparent` and `background` parameters must[m
[32m+[m[32m        be a tuple with three integer values for red, green, blue, or[m
[32m+[m[32m        a simple integer (or singleton tuple) for a greyscale image.[m
[32m+[m
[32m+[m[32m        If specified, the `gamma` parameter must be a positive number[m
[32m+[m[32m        (generally, a float).  A ``gAMA`` chunk will be created.  Note that[m
[32m+[m[32m        this will not change the values of the pixels as they appear in[m
[32m+[m[32m        the PNG file, they are assumed to have already been converted[m
[32m+[m[32m        appropriately for the gamma specified.[m
[32m+[m
[32m+[m[32m        The `compression` argument specifies the compression level[m
[32m+[m[32m        to be used by the ``zlib`` module.  Higher values are likely[m
[32m+[m[32m        to compress better, but will be slower to compress.  The[m
[32m+[m[32m        default for this argument is ``None``; this does not mean[m
[32m+[m[32m        no compression, rather it means that the default from the[m
[32m+[m[32m        ``zlib`` module is used (which is generally acceptable).[m
[32m+[m
[32m+[m[32m        If `interlace` is true then an interlaced image is created[m
[32m+[m[32m        (using PNG's so far only interlace method, *Adam7*).  This does not[m
[32m+[m[32m        affect how the pixels should be presented to the encoder, rather[m
[32m+[m[32m        it changes how they are arranged into the PNG file.  On slow[m
[32m+[m[32m        connexions interlaced images can be partially decoded by the[m
[32m+[m[32m        browser to give a rough view of the image that is successively[m
[32m+[m[32m        refined as more image data appears.[m
[32m+[m
[32m+[m[32m        .. note ::[m
[32m+[m
[32m+[m[32m          Enabling the `interlace` option requires the entire image[m
[32m+[m[32m          to be processed in working memory.[m
[32m+[m
[32m+[m[32m        `chunk_limit` is used to limit the amount of memory used whilst[m
[32m+[m[32m        compressing the image.  In order to avoid using large amounts of[m
[32m+[m[32m        memory, multiple ``IDAT`` chunks may be created.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # At the moment the `planes` argument is ignored;[m
[32m+[m[32m        # its purpose is to act as a dummy so that[m
[32m+[m[32m        # ``Writer(x, y, **info)`` works, where `info` is a dictionary[m
[32m+[m[32m        # returned by Reader.read and friends.[m
[32m+[m[32m        # Ditto for `colormap`.[m
[32m+[m
[32m+[m[32m        # A couple of helper functions come first.  Best skipped if you[m
[32m+[m[32m        # are reading through.[m
[32m+[m
[32m+[m[32m        def isinteger(x):[m
[32m+[m[32m            try:[m
[32m+[m[32m                return int(x) == x[m
[32m+[m[32m            except:[m
[32m+[m[32m                return False[m
[32m+[m
[32m+[m[32m        def check_color(c, which):[m
[32m+[m[32m            """Checks that a colour argument for transparent or[m
[32m+[m[32m            background options is the right form.  Also "corrects" bare[m
[32m+[m[32m            integers to 1-tuples.[m
[32m+[m[32m            """[m
[32m+[m
[32m+[m[32m            if c is None:[m
[32m+[m[32m                return c[m
[32m+[m[32m            if greyscale:[m
[32m+[m[32m                try:[m
[32m+[m[32m                    l = len(c)[m
[32m+[m[32m                except TypeError:[m
[32m+[m[32m                    c = (c,)[m
[32m+[m[32m                if len(c) != 1:[m
[32m+[m[32m                    raise ValueError(f"{which} for greyscale must be 1-tuple")[m
[32m+[m[32m                if not isinteger(c[0]):[m
[32m+[m[32m                    raise ValueError(f"{which} colour for greyscale must be integer")[m
[32m+[m[32m            else:[m
[32m+[m[32m                if not ([m
[32m+[m[32m                    len(c) == 3[m
[32m+[m[32m                    and isinteger(c[0])[m
[32m+[m[32m                    and isinteger(c[1])[m
[32m+[m[32m                    and isinteger(c[2])[m
[32m+[m[32m                ):[m
[32m+[m[32m                    raise ValueError(f"{which} colour must be a triple of integers")[m
[32m+[m[32m            return c[m
[32m+[m
[32m+[m[32m        if size:[m
[32m+[m[32m            if len(size) != 2:[m
[32m+[m[32m                raise ValueError("size argument should be a pair (width, height)")[m
[32m+[m[32m            if width is not None and width != size[0]:[m
[32m+[m[32m                raise ValueError([m
[32m+[m[32m                    "size[0] (%r) and width (%r) should match when both are used."[m
[32m+[m[32m                    % (size[0], width)[m
[32m+[m[32m                )[m
[32m+[m[32m            if height is not None and height != size[1]:[m
[32m+[m[32m                raise ValueError([m
[32m+[m[32m                    "size[1] (%r) and height (%r) should match when both are used."[m
[32m+[m[32m                    % (size[1], height)[m
[32m+[m[32m                )[m
[32m+[m[32m            width, height = size[m
[32m+[m[32m        del size[m
[32m+[m
[32m+[m[32m        if width <= 0 or height <= 0:[m
[32m+[m[32m            raise ValueError("width and height must be greater than zero")[m
[32m+[m[32m        if not isinteger(width) or not isinteger(height):[m
[32m+[m[32m            raise ValueError("width and height must be integers")[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#7Integers-and-byte-order[m
[32m+[m[32m        if width > 2**32 - 1 or height > 2**32 - 1:[m
[32m+[m[32m            raise ValueError("width and height cannot exceed 2**32-1")[m
[32m+[m
[32m+[m[32m        if alpha and transparent is not None:[m
[32m+[m[32m            raise ValueError("transparent colour not allowed with alpha channel")[m
[32m+[m
[32m+[m[32m        if bytes_per_sample is not None:[m
[32m+[m[32m            warnings.warn([m
[32m+[m[32m                "please use bitdepth instead of bytes_per_sample", DeprecationWarning[m
[32m+[m[32m            )[m
[32m+[m[32m            if bytes_per_sample not in (0.125, 0.25, 0.5, 1, 2):[m
[32m+[m[32m                raise ValueError("bytes per sample must be .125, .25, .5, 1, or 2")[m
[32m+[m[32m            bitdepth = int(8 * bytes_per_sample)[m
[32m+[m[32m        del bytes_per_sample[m
[32m+[m[32m        if not isinteger(bitdepth) or bitdepth < 1 or 16 < bitdepth:[m
[32m+[m[32m            raise ValueError([m
[32m+[m[32m                f"bitdepth ({bitdepth!r}) must be a positive integer <= 16"[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        self.rescale = None[m
[32m+[m[32m        if palette:[m
[32m+[m[32m            if bitdepth not in (1, 2, 4, 8):[m
[32m+[m[32m                raise ValueError("with palette, bitdepth must be 1, 2, 4, or 8")[m
[32m+[m[32m            if transparent is not None:[m
[32m+[m[32m                raise ValueError("transparent and palette not compatible")[m
[32m+[m[32m            if alpha:[m
[32m+[m[32m                raise ValueError("alpha and palette not compatible")[m
[32m+[m[32m            if greyscale:[m
[32m+[m[32m                raise ValueError("greyscale and palette not compatible")[m
[32m+[m[32m        else:[m
[32m+[m[32m            # No palette, check for sBIT chunk generation.[m
[32m+[m[32m            if alpha or not greyscale:[m
[32m+[m[32m                if bitdepth not in (8, 16):[m
[32m+[m[32m                    targetbitdepth = (8, 16)[bitdepth > 8][m
[32m+[m[32m                    self.rescale = (bitdepth, targetbitdepth)[m
[32m+[m[32m                    bitdepth = targetbitdepth[m
[32m+[m[32m                    del targetbitdepth[m
[32m+[m[32m            else:[m
[32m+[m[32m                assert greyscale[m
[32m+[m[32m                assert not alpha[m
[32m+[m[32m                if bitdepth not in (1, 2, 4, 8, 16):[m
[32m+[m[32m                    if bitdepth > 8:[m
[32m+[m[32m                        targetbitdepth = 16[m
[32m+[m[32m                    elif bitdepth == 3:[m
[32m+[m[32m                        targetbitdepth = 4[m
[32m+[m[32m                    else:[m
[32m+[m[32m                        assert bitdepth in (5, 6, 7)[m
[32m+[m[32m                        targetbitdepth = 8[m
[32m+[m[32m                    self.rescale = (bitdepth, targetbitdepth)[m
[32m+[m[32m                    bitdepth = targetbitdepth[m
[32m+[m[32m                    del targetbitdepth[m
[32m+[m
[32m+[m[32m        if bitdepth < 8 and (alpha or not greyscale and not palette):[m
[32m+[m[32m            raise ValueError("bitdepth < 8 only permitted with greyscale or palette")[m
[32m+[m[32m        if bitdepth > 8 and palette:[m
[32m+[m[32m            raise ValueError("bit depth must be 8 or less for images with palette")[m
[32m+[m
[32m+[m[32m        transparent = check_color(transparent, "transparent")[m
[32m+[m[32m        background = check_color(background, "background")[m
[32m+[m
[32m+[m[32m        # It's important that the true boolean values (greyscale, alpha,[m
[32m+[m[32m        # colormap, interlace) are converted to bool because Iverson's[m
[32m+[m[32m        # convention is relied upon later on.[m
[32m+[m[32m        self.width = width[m
[32m+[m[32m        self.height = height[m
[32m+[m[32m        self.transparent = transparent[m
[32m+[m[32m        self.background = background[m
[32m+[m[32m        self.gamma = gamma[m
[32m+[m[32m        self.greyscale = bool(greyscale)[m
[32m+[m[32m        self.alpha = bool(alpha)[m
[32m+[m[32m        self.colormap = bool(palette)[m
[32m+[m[32m        self.bitdepth = int(bitdepth)[m
[32m+[m[32m        self.compression = compression[m
[32m+[m[32m        self.chunk_limit = chunk_limit[m
[32m+[m[32m        self.interlace = bool(interlace)[m
[32m+[m[32m        self.palette = check_palette(palette)[m
[32m+[m
[32m+[m[32m        self.color_type = 4 * self.alpha + 2 * (not greyscale) + 1 * self.colormap[m
[32m+[m[32m        assert self.color_type in (0, 2, 3, 4, 6)[m
[32m+[m
[32m+[m[32m        self.color_planes = (3, 1)[self.greyscale or self.colormap][m
[32m+[m[32m        self.planes = self.color_planes + self.alpha[m
[32m+[m[32m        # :todo: fix for bitdepth < 8[m
[32m+[m[32m        self.psize = (self.bitdepth / 8) * self.planes[m
[32m+[m
[32m+[m[32m    def make_palette(self):[m
[32m+[m[32m        """Create the byte sequences for a ``PLTE`` and if necessary a[m
[32m+[m[32m        ``tRNS`` chunk.  Returned as a pair (*p*, *t*).  *t* will be[m
[32m+[m[32m        ``None`` if no ``tRNS`` chunk is necessary.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        p = array("B")[m
[32m+[m[32m        t = array("B")[m
[32m+[m
[32m+[m[32m        for x in self.palette:[m
[32m+[m[32m            p.extend(x[0:3])[m
[32m+[m[32m            if len(x) > 3:[m
[32m+[m[32m                t.append(x[3])[m
[32m+[m[32m        p = tostring(p)[m
[32m+[m[32m        t = tostring(t)[m
[32m+[m[32m        if t:[m
[32m+[m[32m            return p, t[m
[32m+[m[32m        return p, None[m
[32m+[m
[32m+[m[32m    def write(self, outfile, rows):[m
[32m+[m[32m        """Write a PNG image to the output file.  `rows` should be[m
[32m+[m[32m        an iterable that yields each row in boxed row flat pixel format.[m
[32m+[m[32m        The rows should be the rows of the original image, so there[m
[32m+[m[32m        should be ``self.height`` rows of ``self.width * self.planes`` values.[m
[32m+[m[32m        If `interlace` is specified (when creating the instance), then[m
[32m+[m[32m        an interlaced PNG file will be written.  Supply the rows in the[m
[32m+[m[32m        normal image order; the interlacing is carried out internally.[m
[32m+[m
[32m+[m[32m        .. note ::[m
[32m+[m
[32m+[m[32m          Interlacing will require the entire image to be in working memory.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        if self.interlace:[m
[32m+[m[32m            fmt = "BH"[self.bitdepth > 8][m
[32m+[m[32m            a = array(fmt, itertools.chain(*rows))[m
[32m+[m[32m            return self.write_array(outfile, a)[m
[32m+[m[32m        else:[m
[32m+[m[32m            nrows = self.write_passes(outfile, rows)[m
[32m+[m[32m            if nrows != self.height:[m
[32m+[m[32m                raise ValueError([m
[32m+[m[32m                    "rows supplied (%d) does not match height (%d)"[m
[32m+[m[32m                    % (nrows, self.height)[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m    def write_passes(self, outfile, rows, packed=False):[m
[32m+[m[32m        """[m
[32m+[m[32m        Write a PNG image to the output file.[m
[32m+[m
[32m+[m[32m        Most users are expected to find the :meth:`write` or[m
[32m+[m[32m        :meth:`write_array` method more convenient.[m
[32m+[m
[32m+[m[32m        The rows should be given to this method in the order that[m
[32m+[m[32m        they appear in the output file.  For straightlaced images,[m
[32m+[m[32m        this is the usual top to bottom ordering, but for interlaced[m
[32m+[m[32m        images the rows should have already been interlaced before[m
[32m+[m[32m        passing them to this function.[m
[32m+[m
[32m+[m[32m        `rows` should be an iterable that yields each row.  When[m
[32m+[m[32m        `packed` is ``False`` the rows should be in boxed row flat pixel[m
[32m+[m[32m        format; when `packed` is ``True`` each row should be a packed[m
[32m+[m[32m        sequence of bytes.[m
[32m+[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#5PNG-file-signature[m
[32m+[m[32m        outfile.write(_signature)[m
[32m+[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#11IHDR[m
[32m+[m[32m        write_chunk([m
[32m+[m[32m            outfile,[m
[32m+[m[32m            "IHDR",[m
[32m+[m[32m            struct.pack([m
[32m+[m[32m                "!2I5B",[m
[32m+[m[32m                self.width,[m
[32m+[m[32m                self.height,[m
[32m+[m[32m                self.bitdepth,[m
[32m+[m[32m                self.color_type,[m
[32m+[m[32m                0,[m
[32m+[m[32m                0,[m
[32m+[m[32m                self.interlace,[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        # See :chunk:order[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#11gAMA[m
[32m+[m[32m        if self.gamma is not None:[m
[32m+[m[32m            write_chunk([m
[32m+[m[32m                outfile, "gAMA", struct.pack("!L", int(round(self.gamma * 1e5)))[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        # See :chunk:order[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#11sBIT[m
[32m+[m[32m        if self.rescale:[m
[32m+[m[32m            write_chunk([m
[32m+[m[32m                outfile,[m
[32m+[m[32m                "sBIT",[m
[32m+[m[32m                struct.pack("%dB" % self.planes, *[self.rescale[0]] * self.planes),[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        # :chunk:order: Without a palette (PLTE chunk), ordering is[m
[32m+[m[32m        # relatively relaxed.  With one, gAMA chunk must precede PLTE[m
[32m+[m[32m        # chunk which must precede tRNS and bKGD.[m
[32m+[m[32m        # See http://www.w3.org/TR/PNG/#5ChunkOrdering[m
[32m+[m[32m        if self.palette:[m
[32m+[m[32m            p, t = self.make_palette()[m
[32m+[m[32m            write_chunk(outfile, "PLTE", p)[m
[32m+[m[32m            if t:[m
[32m+[m[32m                # tRNS chunk is optional.  Only needed if palette entries[m
[32m+[m[32m                # have alpha.[m
[32m+[m[32m                write_chunk(outfile, "tRNS", t)[m
[32m+[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#11tRNS[m
[32m+[m[32m        if self.transparent is not None:[m
[32m+[m[32m            if self.greyscale:[m
[32m+[m[32m                write_chunk(outfile, "tRNS", struct.pack("!1H", *self.transparent))[m
[32m+[m[32m            else:[m
[32m+[m[32m                write_chunk(outfile, "tRNS", struct.pack("!3H", *self.transparent))[m
[32m+[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#11bKGD[m
[32m+[m[32m        if self.background is not None:[m
[32m+[m[32m            if self.greyscale:[m
[32m+[m[32m                write_chunk(outfile, "bKGD", struct.pack("!1H", *self.background))[m
[32m+[m[32m            else:[m
[32m+[m[32m                write_chunk(outfile, "bKGD", struct.pack("!3H", *self.background))[m
[32m+[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#11IDAT[m
[32m+[m[32m        if self.compression is not None:[m
[32m+[m[32m            compressor = zlib.compressobj(self.compression)[m
[32m+[m[32m        else:[m
[32m+[m[32m            compressor = zlib.compressobj()[m
[32m+[m
[32m+[m[32m        # Choose an extend function based on the bitdepth.  The extend[m
[32m+[m[32m        # function packs/decomposes the pixel values into bytes and[m
[32m+[m[32m        # stuffs them onto the data array.[m
[32m+[m[32m        data = array("B")[m
[32m+[m[32m        if self.bitdepth == 8 or packed:[m
[32m+[m[32m            extend = data.extend[m
[32m+[m[32m        elif self.bitdepth == 16:[m
[32m+[m[32m            # Decompose into bytes[m
[32m+[m[32m            def extend(sl):[m
[32m+[m[32m                fmt = f"!{len(sl)}H"[m
[32m+[m[32m                data.extend(array("B", struct.pack(fmt, *sl)))[m
[32m+[m
[32m+[m[32m        else:[m
[32m+[m[32m            # Pack into bytes[m
[32m+[m[32m            assert self.bitdepth < 8[m
[32m+[m[32m            # samples per byte[m
[32m+[m[32m            spb = int(8 / self.bitdepth)[m
[32m+[m
[32m+[m[32m            def extend(sl):[m
[32m+[m[32m                a = array("B", sl)[m
[32m+[m[32m                # Adding padding bytes so we can group into a whole[m
[32m+[m[32m                # number of spb-tuples.[m
[32m+[m[32m                l = float(len(a))[m
[32m+[m[32m                extra = math.ceil(l / float(spb)) * spb - l[m
[32m+[m[32m                a.extend([0] * int(extra))[m
[32m+[m[32m                # Pack into bytes[m
[32m+[m[32m                l = group(a, spb)[m
[32m+[m[32m                l = (reduce(lambda x, y: (x << self.bitdepth) + y, e) for e in l)[m
[32m+[m[32m                data.extend(l)[m
[32m+[m
[32m+[m[32m        if self.rescale:[m
[32m+[m[32m            oldextend = extend[m
[32m+[m[32m            factor = float(2 ** self.rescale[1] - 1) / float(2 ** self.rescale[0] - 1)[m
[32m+[m
[32m+[m[32m            def extend(sl):[m
[32m+[m[32m                oldextend((int(round(factor * x)) for x in sl))[m
[32m+[m
[32m+[m[32m        # Build the first row, testing mostly to see if we need to[m
[32m+[m[32m        # changed the extend function to cope with NumPy integer types[m
[32m+[m[32m        # (they cause our ordinary definition of extend to fail, so we[m
[32m+[m[32m        # wrap it).  See[m
[32m+[m[32m        # http://code.google.com/p/pypng/issues/detail?id=44[m
[32m+[m[32m        enumrows = enumerate(rows)[m
[32m+[m[32m        del rows[m
[32m+[m
[32m+[m[32m        # First row's filter type.[m
[32m+[m[32m        data.append(0)[m
[32m+[m[32m        # :todo: Certain exceptions in the call to ``.next()`` or the[m
[32m+[m[32m        # following try would indicate no row data supplied.[m
[32m+[m[32m        # Should catch.[m
[32m+[m[32m        i, row = next(enumrows)[m
[32m+[m[32m        try:[m
[32m+[m[32m            # If this fails...[m
[32m+[m[32m            extend(row)[m
[32m+[m[32m        except:[m
[32m+[m[32m            # ... try a version that converts the values to int first.[m
[32m+[m[32m            # Not only does this work for the (slightly broken) NumPy[m
[32m+[m[32m            # types, there are probably lots of other, unknown, "nearly"[m
[32m+[m[32m            # int types it works for.[m
[32m+[m[32m            def wrapmapint(f):[m
[32m+[m[32m                return lambda sl: f(map(int, sl))[m
[32m+[m
[32m+[m[32m            extend = wrapmapint(extend)[m
[32m+[m[32m            del wrapmapint[m
[32m+[m[32m            extend(row)[m
[32m+[m
[32m+[m[32m        for i, row in enumrows:[m
[32m+[m[32m            # Add "None" filter type.  Currently, it's essential that[m
[32m+[m[32m            # this filter type be used for every scanline as we do not[m
[32m+[m[32m            # mark the first row of a reduced pass image; that means we[m
[32m+[m[32m            # could accidentally compute the wrong filtered scanline if[m
[32m+[m[32m            # we used "up", "average", or "paeth" on such a line.[m
[32m+[m[32m            data.append(0)[m
[32m+[m[32m            extend(row)[m
[32m+[m[32m            if len(data) > self.chunk_limit:[m
[32m+[m[32m                compressed = compressor.compress(tostring(data))[m
[32m+[m[32m                if len(compressed):[m
[32m+[m[32m                    # print(len(data), len(compressed), file= >> sys.stderr)[m
[32m+[m[32m                    write_chunk(outfile, "IDAT", compressed)[m
[32m+[m[32m                # Because of our very witty definition of ``extend``,[m
[32m+[m[32m                # above, we must reuse the same ``data`` object.  Hence[m
[32m+[m[32m                # we use ``del`` to empty this one, rather than create a[m
[32m+[m[32m                # fresh one (which would be my natural FP instinct).[m
[32m+[m[32m                del data[:][m
[32m+[m[32m        if len(data):[m
[32m+[m[32m            compressed = compressor.compress(tostring(data))[m
[32m+[m[32m        else:[m
[32m+[m[32m            compressed = ""[m
[32m+[m[32m        flushed = compressor.flush()[m
[32m+[m[32m        if len(compressed) or len(flushed):[m
[32m+[m[32m            # print(len(data), len(compressed), len(flushed), file=sys.stderr)[m
[32m+[m[32m            write_chunk(outfile, "IDAT", compressed + flushed)[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#11IEND[m
[32m+[m[32m        write_chunk(outfile, "IEND")[m
[32m+[m[32m        return i + 1[m
[32m+[m
[32m+[m[32m    def write_array(self, outfile, pixels):[m
[32m+[m[32m        """[m
[32m+[m[32m        Write an array in flat row flat pixel format as a PNG file on[m
[32m+[m[32m        the output file.  See also :meth:`write` method.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        if self.interlace:[m
[32m+[m[32m            self.write_passes(outfile, self.array_scanlines_interlace(pixels))[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.write_passes(outfile, self.array_scanlines(pixels))[m
[32m+[m
[32m+[m[32m    def write_packed(self, outfile, rows):[m
[32m+[m[32m        """[m
[32m+[m[32m        Write PNG file to `outfile`.  The pixel data comes from `rows`[m
[32m+[m[32m        which should be in boxed row packed format.  Each row should be[m
[32m+[m[32m        a sequence of packed bytes.[m
[32m+[m
[32m+[m[32m        Technically, this method does work for interlaced images but it[m
[32m+[m[32m        is best avoided.  For interlaced images, the rows should be[m
[32m+[m[32m        presented in the order that they appear in the file.[m
[32m+[m
[32m+[m[32m        This method should not be used when the source image bit depth[m
[32m+[m[32m        is not one naturally supported by PNG; the bit depth should be[m
[32m+[m[32m        1, 2, 4, 8, or 16.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        if self.rescale:[m
[32m+[m[32m            raise Error([m
[32m+[m[32m                "write_packed method not suitable for bit depth %d" % self.rescale[0][m
[32m+[m[32m            )[m
[32m+[m[32m        return self.write_passes(outfile, rows, packed=True)[m
[32m+[m
[32m+[m[32m    def convert_pnm(self, infile, outfile):[m
[32m+[m[32m        """[m
[32m+[m[32m        Convert a PNM file containing raw pixel data into a PNG file[m
[32m+[m[32m        with the parameters set in the writer object.  Works for[m
[32m+[m[32m        (binary) PGM, PPM, and PAM formats.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        if self.interlace:[m
[32m+[m[32m            pixels = array("B")[m
[32m+[m[32m            pixels.fromfile([m
[32m+[m[32m                infile,[m
[32m+[m[32m                (self.bitdepth / 8) * self.color_planes * self.width * self.height,[m
[32m+[m[32m            )[m
[32m+[m[32m            self.write_passes(outfile, self.array_scanlines_interlace(pixels))[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.write_passes(outfile, self.file_scanlines(infile))[m
[32m+[m
[32m+[m[32m    def convert_ppm_and_pgm(self, ppmfile, pgmfile, outfile):[m
[32m+[m[32m        """[m
[32m+[m[32m        Convert a PPM and PGM file containing raw pixel data into a[m
[32m+[m[32m        PNG outfile with the parameters set in the writer object.[m
[32m+[m[32m        """[m
[32m+[m[32m        pixels = array("B")[m
[32m+[m[32m        pixels.fromfile([m
[32m+[m[32m            ppmfile, (self.bitdepth / 8) * self.color_planes * self.width * self.height[m
[32m+[m[32m        )[m
[32m+[m[32m        apixels = array("B")[m
[32m+[m[32m        apixels.fromfile(pgmfile, (self.bitdepth / 8) * self.width * self.height)[m
[32m+[m[32m        pixels = interleave_planes([m
[32m+[m[32m            pixels,[m
[32m+[m[32m            apixels,[m
[32m+[m[32m            (self.bitdepth / 8) * self.color_planes,[m
[32m+[m[32m            (self.bitdepth / 8),[m
[32m+[m[32m        )[m
[32m+[m[32m        if self.interlace:[m
[32m+[m[32m            self.write_passes(outfile, self.array_scanlines_interlace(pixels))[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.write_passes(outfile, self.array_scanlines(pixels))[m
[32m+[m
[32m+[m[32m    def file_scanlines(self, infile):[m
[32m+[m[32m        """[m
[32m+[m[32m        Generates boxed rows in flat pixel format, from the input file[m
[32m+[m[32m        `infile`.  It assumes that the input file is in a "Netpbm-like"[m
[32m+[m[32m        binary format, and is positioned at the beginning of the first[m
[32m+[m[32m        pixel.  The number of pixels to read is taken from the image[m
[32m+[m[32m        dimensions (`width`, `height`, `planes`) and the number of bytes[m
[32m+[m[32m        per value is implied by the image `bitdepth`.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # Values per row[m
[32m+[m[32m        vpr = self.width * self.planes[m
[32m+[m[32m        row_bytes = vpr[m
[32m+[m[32m        if self.bitdepth > 8:[m
[32m+[m[32m            assert self.bitdepth == 16[m
[32m+[m[32m            row_bytes *= 2[m
[32m+[m[32m            fmt = ">%dH" % vpr[m
[32m+[m
[32m+[m[32m            def line():[m
[32m+[m[32m                return array("H", struct.unpack(fmt, infile.read(row_bytes)))[m
[32m+[m
[32m+[m[32m        else:[m
[32m+[m
[32m+[m[32m            def line():[m
[32m+[m[32m                scanline = array("B", infile.read(row_bytes))[m
[32m+[m[32m                return scanline[m
[32m+[m
[32m+[m[32m        for y in range(self.height):[m
[32m+[m[32m            yield line()[m
[32m+[m
[32m+[m[32m    def array_scanlines(self, pixels):[m
[32m+[m[32m        """[m
[32m+[m[32m        Generates boxed rows (flat pixels) from flat rows (flat pixels)[m
[32m+[m[32m        in an array.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # Values per row[m
[32m+[m[32m        vpr = self.width * self.planes[m
[32m+[m[32m        stop = 0[m
[32m+[m[32m        for y in range(self.height):[m
[32m+[m[32m            start = stop[m
[32m+[m[32m            stop = start + vpr[m
[32m+[m[32m            yield pixels[start:stop][m
[32m+[m
[32m+[m[32m    def array_scanlines_interlace(self, pixels):[m
[32m+[m[32m        """[m
[32m+[m[32m        Generator for interlaced scanlines from an array.  `pixels` is[m
[32m+[m[32m        the full source image in flat row flat pixel format.  The[m
[32m+[m[32m        generator yields each scanline of the reduced passes in turn, in[m
[32m+[m[32m        boxed row flat pixel format.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#8InterlaceMethods[m
[32m+[m[32m        # Array type.[m
[32m+[m[32m        fmt = "BH"[self.bitdepth > 8][m
[32m+[m[32m        # Value per row[m
[32m+[m[32m        vpr = self.width * self.planes[m
[32m+[m[32m        for xstart, ystart, xstep, ystep in _adam7:[m
[32m+[m[32m            if xstart >= self.width:[m
[32m+[m[32m                continue[m
[32m+[m[32m            # Pixels per row (of reduced image)[m
[32m+[m[32m            ppr = int(math.ceil((self.width - xstart) / float(xstep)))[m
[32m+[m[32m            # number of values in reduced image row.[m
[32m+[m[32m            row_len = ppr * self.planes[m
[32m+[m[32m            for y in range(ystart, self.height, ystep):[m
[32m+[m[32m                if xstep == 1:[m
[32m+[m[32m                    offset = y * vpr[m
[32m+[m[32m                    yield pixels[offset : offset + vpr][m
[32m+[m[32m                else:[m
[32m+[m[32m                    row = array(fmt)[m
[32m+[m[32m                    # There's no easier way to set the length of an array[m
[32m+[m[32m                    row.extend(pixels[0:row_len])[m
[32m+[m[32m                    offset = y * vpr + xstart * self.planes[m
[32m+[m[32m                    end_offset = (y + 1) * vpr[m
[32m+[m[32m                    skip = self.planes * xstep[m
[32m+[m[32m                    for i in range(self.planes):[m
[32m+[m[32m                        row[i :: self.planes] = pixels[offset + i : end_offset : skip][m
[32m+[m[32m                    yield row[m
[32m+[m
[32m+[m
[32m+[m[32mdef write_chunk(outfile, tag, data=strtobytes("")):[m
[32m+[m[32m    """[m
[32m+[m[32m    Write a PNG chunk to the output file, including length and[m
[32m+[m[32m    checksum.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    # http://www.w3.org/TR/PNG/#5Chunk-layout[m
[32m+[m[32m    outfile.write(struct.pack("!I", len(data)))[m
[32m+[m[32m    tag = strtobytes(tag)[m
[32m+[m[32m    outfile.write(tag)[m
[32m+[m[32m    outfile.write(data)[m
[32m+[m[32m    checksum = zlib.crc32(tag)[m
[32m+[m[32m    checksum = zlib.crc32(data, checksum)[m
[32m+[m[32m    checksum &= 2**32 - 1[m
[32m+[m[32m    outfile.write(struct.pack("!I", checksum))[m
[32m+[m
[32m+[m
[32m+[m[32mdef write_chunks(out, chunks):[m
[32m+[m[32m    """Create a PNG file by writing out the chunks."""[m
[32m+[m
[32m+[m[32m    out.write(_signature)[m
[32m+[m[32m    for chunk in chunks:[m
[32m+[m[32m        write_chunk(out, *chunk)[m
[32m+[m
[32m+[m
[32m+[m[32mdef filter_scanline(type, line, fo, prev=None):[m
[32m+[m[32m    """Apply a scanline filter to a scanline.  `type` specifies the[m
[32m+[m[32m    filter type (0 to 4); `line` specifies the current (unfiltered)[m
[32m+[m[32m    scanline as a sequence of bytes; `prev` specifies the previous[m
[32m+[m[32m    (unfiltered) scanline as a sequence of bytes. `fo` specifies the[m
[32m+[m[32m    filter offset; normally this is size of a pixel in bytes (the number[m
[32m+[m[32m    of bytes per sample times the number of channels), but when this is[m
[32m+[m[32m    < 1 (for bit depths < 8) then the filter offset is 1.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    assert 0 <= type < 5[m
[32m+[m
[32m+[m[32m    # The output array.  Which, pathetically, we extend one-byte at a[m
[32m+[m[32m    # time (fortunately this is linear).[m
[32m+[m[32m    out = array("B", [type])[m
[32m+[m
[32m+[m[32m    def sub():[m
[32m+[m[32m        ai = -fo[m
[32m+[m[32m        for x in line:[m
[32m+[m[32m            if ai >= 0:[m
[32m+[m[32m                x = (x - line[ai]) & 0xFF[m
[32m+[m[32m            out.append(x)[m
[32m+[m[32m            ai += 1[m
[32m+[m
[32m+[m[32m    def up():[m
[32m+[m[32m        for i, x in enumerate(line):[m
[32m+[m[32m            x = (x - prev[i]) & 0xFF[m
[32m+[m[32m            out.append(x)[m
[32m+[m
[32m+[m[32m    def average():[m
[32m+[m[32m        ai = -fo[m
[32m+[m[32m        for i, x in enumerate(line):[m
[32m+[m[32m            if ai >= 0:[m
[32m+[m[32m                x = (x - ((line[ai] + prev[i]) >> 1)) & 0xFF[m
[32m+[m[32m            else:[m
[32m+[m[32m                x = (x - (prev[i] >> 1)) & 0xFF[m
[32m+[m[32m            out.append(x)[m
[32m+[m[32m            ai += 1[m
[32m+[m
[32m+[m[32m    def paeth():[m
[32m+[m[32m        # http://www.w3.org/TR/PNG/#9Filter-type-4-Paeth[m
[32m+[m[32m        ai = -fo  # also used for ci[m
[32m+[m[32m        for i, x in enumerate(line):[m
[32m+[m[32m            a = 0[m
[32m+[m[32m            b = prev[i][m
[32m+[m[32m            c = 0[m
[32m+[m
[32m+[m[32m            if ai >= 0:[m
[32m+[m[32m                a = line[ai][m
[32m+[m[32m                c = prev[ai][m
[32m+[m[32m            p = a + b - c[m
[32m+[m[32m            pa = abs(p - a)[m
[32m+[m[32m            pb = abs(p - b)[m
[32m+[m[32m            pc = abs(p - c)[m
[32m+[m[32m            if pa <= pb and pa <= pc:[m
[32m+[m[32m                Pr = a[m
[32m+[m[32m            elif pb <= pc:[m
[32m+[m[32m                Pr = b[m
[32m+[m[32m            else:[m
[32m+[m[32m                Pr = c[m
[32m+[m
[32m+[m[32m            x = (x - Pr) & 0xFF[m
[32m+[m[32m            out.append(x)[m
[32m+[m[32m            ai += 1[m
[32m+[m
[32m+[m[32m    if not prev:[m
[32m+[m[32m        # We're on the first line.  Some of the filters can be reduced[m
[32m+[m[32m        # to simpler cases which makes handling the line "off the top"[m
[32m+[m[32m        # of the image simpler.  "up" becomes "none"; "paeth" becomes[m
[32m+[m[32m        # "left" (non-trivial, but true). "average" needs to be handled[m
[32m+[m[32m        # specially.[m
[32m+[m[32m        if type == 2:  # "up"[m
[32m+[m[32m            return line  # type = 0[m
[32m+[m[32m        elif type == 3:[m
[32m+[m[32m            prev = [0] * len(line)[m
[32m+[m[32m        elif type == 4:  # "paeth"[m
[32m+[m[32m            type = 1[m
[32m+[m[32m    if type == 0:[m
[32m+[m[32m        out.extend(line)[m
[32m+[m[32m    elif type == 1:[m
[32m+[m[32m        sub()[m
[32m+[m[32m    elif type == 2:[m
[32m+[m[32m        up()[m
[32m+[m[32m    elif type == 3:[m
[32m+[m[32m        average()[m
[32m+[m[32m    else:  # type == 4[m
[32m+[m[32m        paeth()[m
[32m+[m[32m    return out[m
[32m+[m
[32m+[m
[32m+[m[32mdef from_array(a, mode=None, info={}):[m
[32m+[m[32m    """Create a PNG :class:`Image` object from a 2- or 3-dimensional array.[m
[32m+[m[32m    One application of this function is easy PIL-style saving:[m
[32m+[m[32m    ``png.from_array(pixels, 'L').save('foo.png')``.[m
[32m+[m
[32m+[m[32m    .. note :[m
[32m+[m
[32m+[m[32m      The use of the term *3-dimensional* is for marketing purposes[m
[32m+[m[32m      only.  It doesn't actually work.  Please bear with us.  Meanwhile[m
[32m+[m[32m      enjoy the complimentary snacks (on request) and please use a[m
[32m+[m[32m      2-dimensional array.[m
[32m+[m
[32m+[m[32m    Unless they are specified using the *info* parameter, the PNG's[m
[32m+[m[32m    height and width are taken from the array size.  For a 3 dimensional[m
[32m+[m[32m    array the first axis is the height; the second axis is the width;[m
[32m+[m[32m    and the third axis is the channel number.  Thus an RGB image that is[m
[32m+[m[32m    16 pixels high and 8 wide will use an array that is 16x8x3.  For 2[m
[32m+[m[32m    dimensional arrays the first axis is the height, but the second axis[m
[32m+[m[32m    is ``width*channels``, so an RGB image that is 16 pixels high and 8[m
[32m+[m[32m    wide will use a 2-dimensional array that is 16x24 (each row will be[m
[32m+[m[32m    8*3==24 sample values).[m
[32m+[m
[32m+[m[32m    *mode* is a string that specifies the image colour format in a[m
[32m+[m[32m    PIL-style mode.  It can be:[m
[32m+[m
[32m+[m[32m    ``'L'``[m
[32m+[m[32m      greyscale (1 channel)[m
[32m+[m[32m    ``'LA'``[m
[32m+[m[32m      greyscale with alpha (2 channel)[m
[32m+[m[32m    ``'RGB'``[m
[32m+[m[32m      colour image (3 channel)[m
[32m+[m[32m    ``'RGBA'``[m
[32m+[m[32m      colour image with alpha (4 channel)[m
[32m+[m
[32m+[m[32m    The mode string can also specify the bit depth (overriding how this[m
[32m+[m[32m    function normally derives the bit depth, see below).  Appending[m
[32m+[m[32m    ``';16'`` to the mode will cause the PNG to be 16 bits per channel;[m
[32m+[m[32m    any decimal from 1 to 16 can be used to specify the bit depth.[m
[32m+[m
[32m+[m[32m    When a 2-dimensional array is used *mode* determines how many[m
[32m+[m[32m    channels the image has, and so allows the width to be derived from[m
[32m+[m[32m    the second array dimension.[m
[32m+[m
[32m+[m[32m    The array is expected to be a ``numpy`` array, but it can be any[m
[32m+[m[32m    suitable Python sequence.  For example, a list of lists can be used:[m
[32m+[m[32m    ``png.from_array([[0, 255, 0], [255, 0, 255]], 'L')``.  The exact[m
[32m+[m[32m    rules are: ``len(a)`` gives the first dimension, height;[m
[32m+[m[32m    ``len(a[0])`` gives the second dimension; ``len(a[0][0])`` gives the[m
[32m+[m[32m    third dimension, unless an exception is raised in which case a[m
[32m+[m[32m    2-dimensional array is assumed.  It's slightly more complicated than[m
[32m+[m[32m    that because an iterator of rows can be used, and it all still[m
[32m+[m[32m    works.  Using an iterator allows data to be streamed efficiently.[m
[32m+[m
[32m+[m[32m    The bit depth of the PNG is normally taken from the array element's[m
[32m+[m[32m    datatype (but if *mode* specifies a bitdepth then that is used[m
[32m+[m[32m    instead).  The array element's datatype is determined in a way which[m
[32m+[m[32m    is supposed to work both for ``numpy`` arrays and for Python[m
[32m+[m[32m    ``array.array`` objects.  A 1 byte datatype will give a bit depth of[m
[32m+[m[32m    8, a 2 byte datatype will give a bit depth of 16.  If the datatype[m
[32m+[m[32m    does not have an implicit size, for example it is a plain Python[m
[32m+[m[32m    list of lists, as above, then a default of 8 is used.[m
[32m+[m
[32m+[m[32m    The *info* parameter is a dictionary that can be used to specify[m
[32m+[m[32m    metadata (in the same style as the arguments to the[m
[32m+[m[32m    :class:``png.Writer`` class).  For this function the keys that are[m
[32m+[m[32m    useful are:[m
[32m+[m
[32m+[m[32m    height[m
[32m+[m[32m      overrides the height derived from the array dimensions and allows[m
[32m+[m[32m      *a* to be an iterable.[m
[32m+[m[32m    width[m
[32m+[m[32m      overrides the width derived from the array dimensions.[m
[32m+[m[32m    bitdepth[m
[32m+[m[32m      overrides the bit depth derived from the element datatype (but[m
[32m+[m[32m      must match *mode* if that also specifies a bit depth).[m
[32m+[m
[32m+[m[32m    Generally anything specified in the[m
[32m+[m[32m    *info* dictionary will override any implicit choices that this[m
[32m+[m[32m    function would otherwise make, but must match any explicit ones.[m
[32m+[m[32m    For example, if the *info* dictionary has a ``greyscale`` key then[m
[32m+[m[32m    this must be true when mode is ``'L'`` or ``'LA'`` and false when[m
[32m+[m[32m    mode is ``'RGB'`` or ``'RGBA'``.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    # We abuse the *info* parameter by modifying it.  Take a copy here.[m
[32m+[m[32m    # (Also typechecks *info* to some extent).[m
[32m+[m[32m    info = dict(info)[m
[32m+[m
[32m+[m[32m    # Syntax check mode string.[m
[32m+[m[32m    bitdepth = None[m
[32m+[m[32m    try:[m
[32m+[m[32m        mode = mode.split(";")[m
[32m+[m[32m        if len(mode) not in (1, 2):[m
[32m+[m[32m            raise Error()[m
[32m+[m[32m        if mode[0] not in ("L", "LA", "RGB", "RGBA"):[m
[32m+[m[32m            raise Error()[m
[32m+[m[32m        if len(mode) == 2:[m
[32m+[m[32m            try:[m
[32m+[m[32m                bitdepth = int(mode[1])[m
[32m+[m[32m            except:[m
[32m+[m[32m                raise Error()[m
[32m+[m[32m    except Error:[m
[32m+[m[32m        raise Error("mode string should be 'RGB' or 'L;16' or similar.")[m
[32m+[m[32m    mode = mode[0][m
[32m+[m
[32m+[m[32m    # Get bitdepth from *mode* if possible.[m
[32m+[m[32m    if bitdepth:[m
[32m+[m[32m        if info.get("bitdepth") and bitdepth != info["bitdepth"]:[m
[32m+[m[32m            raise Error([m
[32m+[m[32m                "mode bitdepth (%d) should match info bitdepth (%d)."[m
[32m+[m[32m                % (bitdepth, info["bitdepth"])[m
[32m+[m[32m            )[m
[32m+[m[32m        info["bitdepth"] = bitdepth[m
[32m+[m
[32m+[m[32m    # Fill in and/or check entries in *info*.[m
[32m+[m[32m    # Dimensions.[m
[32m+[m[32m    if "size" in info:[m
[32m+[m[32m        # Check width, height, size all match where used.[m
[32m+[m[32m        for dimension, axis in [("width", 0), ("height", 1)]:[m
[32m+[m[32m            if dimension in info:[m
[32m+[m[32m                if info[dimension] != info["size"][axis]:[m
[32m+[m[32m                    raise Error([m
[32m+[m[32m                        f"info[{dimension!r}] should match info['size'][{axis!r}]."[m
[32m+[m[32m                    )[m
[32m+[m[32m        info["width"], info["height"] = info["size"][m
[32m+[m[32m    if "height" not in info:[m
[32m+[m[32m        try:[m
[32m+[m[32m            l = len(a)[m
[32m+[m[32m        except:[m
[32m+[m[32m            raise Error("len(a) does not work, supply info['height'] instead.")[m
[32m+[m[32m        info["height"] = l[m
[32m+[m[32m    # Colour format.[m
[32m+[m[32m    if "greyscale" in info:[m
[32m+[m[32m        if bool(info["greyscale"]) != ("L" in mode):[m
[32m+[m[32m            raise Error("info['greyscale'] should match mode.")[m
[32m+[m[32m    info["greyscale"] = "L" in mode[m
[32m+[m[32m    if "alpha" in info:[m
[32m+[m[32m        if bool(info["alpha"]) != ("A" in mode):[m
[32m+[m[32m            raise Error("info['alpha'] should match mode.")[m
[32m+[m[32m    info["alpha"] = "A" in mode[m
[32m+[m
[32m+[m[32m    planes = len(mode)[m
[32m+[m[32m    if "planes" in info:[m
[32m+[m[32m        if info["planes"] != planes:[m
[32m+[m[32m            raise Error("info['planes'] should match mode.")[m
[32m+[m
[32m+[m[32m    # In order to work out whether we the array is 2D or 3D we need its[m
[32m+[m[32m    # first row, which requires that we take a copy of its iterator.[m
[32m+[m[32m    # We may also need the first row to derive width and bitdepth.[m
[32m+[m[32m    a, t = itertools.tee(a)[m
[32m+[m[32m    row = next(t)[m
[32m+[m[32m    del t[m
[32m+[m[32m    try:[m
[32m+[m[32m        row[0][0][m
[32m+[m[32m        threed = True[m
[32m+[m[32m        testelement = row[0][m
[32m+[m[32m    except:[m
[32m+[m[32m        threed = False[m
[32m+[m[32m        testelement = row[m
[32m+[m[32m    if "width" not in info:[m
[32m+[m[32m        if threed:[m
[32m+[m[32m            width = len(row)[m
[32m+[m[32m        else:[m
[32m+[m[32m            width = len(row) // planes[m
[32m+[m[32m        info["width"] = width[m
[32m+[m
[32m+[m[32m    # Not implemented yet[m
[32m+[m[32m    assert not threed[m
[32m+[m
[32m+[m[32m    if "bitdepth" not in info:[m
[32m+[m[32m        try:[m
[32m+[m[32m            dtype = testelement.dtype[m
[32m+[m[32m            # goto the "else:" clause.  Sorry.[m
[32m+[m[32m        except:[m
[32m+[m[32m            try:[m
[32m+[m[32m                # Try a Python array.array.[m
[32m+[m[32m                bitdepth = 8 * testelement.itemsize[m
[32m+[m[32m            except:[m
[32m+[m[32m                # We can't determine it from the array element's[m
[32m+[m[32m                # datatype, use a default of 8.[m
[32m+[m[32m                bitdepth = 8[m
[32m+[m[32m        else:[m
[32m+[m[32m            # If we got here without exception, we now assume that[m
[32m+[m[32m            # the array is a numpy array.[m
[32m+[m[32m            if dtype.kind == "b":[m
[32m+[m[32m                bitdepth = 1[m
[32m+[m[32m            else:[m
[32m+[m[32m                bitdepth = 8 * dtype.itemsize[m
[32m+[m[32m        info["bitdepth"] = bitdepth[m
[32m+[m
[32m+[m[32m    for thing in "width height bitdepth greyscale alpha".split():[m
[32m+[m[32m        assert thing in info[m
[32m+[m[32m    return Image(a, info)[m
[32m+[m
[32m+[m
[32m+[m[32m# So that refugee's from PIL feel more at home.  Not documented.[m
[32m+[m[32mfromarray = from_array[m
[32m+[m
[32m+[m
[32m+[m[32mclass Image:[m
[32m+[m[32m    """A PNG image.[m
[32m+[m[32m    You can create an :class:`Image` object from an array of pixels by calling[m
[32m+[m[32m    :meth:`png.from_array`.  It can be saved to disk with the[m
[32m+[m[32m    :meth:`save` method."""[m
[32m+[m
[32m+[m[32m    def __init__(self, rows, info):[m
[32m+[m[32m        """[m
[32m+[m[32m        .. note ::[m
[32m+[m
[32m+[m[32m          The constructor is not public.  Please do not call it.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        self.rows = rows[m
[32m+[m[32m        self.info = info[m
[32m+[m
[32m+[m[32m    def save(self, file):[m
[32m+[m[32m        """Save the image to *file*.  If *file* looks like an open file[m
[32m+[m[32m        descriptor then it is used, otherwise it is treated as a[m
[32m+[m[32m        filename and a fresh file is opened.[m
[32m+[m
[32m+[m[32m        In general, you can only call this method once; after it has[m
[32m+[m[32m        been called the first time and the PNG image has been saved, the[m
[32m+[m[32m        source data will have been streamed, and cannot be streamed[m
[32m+[m[32m        again.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        w = Writer(**self.info)[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            file.write[m
[32m+[m
[32m+[m[32m            def close():[m
[32m+[m[32m                pass[m
[32m+[m
[32m+[m[32m        except:[m
[32m+[m[32m            file = open(file, "wb")[m
[32m+[m
[32m+[m[32m            def close():[m
[32m+[m[32m                file.close()[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            w.write(file, self.rows)[m
[32m+[m[32m        finally:[m
[32m+[m[32m            close()[m
[32m+[m
[32m+[m
[32m+[m[32mclass _readable:[m
[32m+[m[32m    """[m
[32m+[m[32m    A simple file-like interface for strings and arrays.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, buf):[m
[32m+[m[32m        self.buf = buf[m
[32m+[m[32m        self.offset = 0[m
[32m+[m
[32m+[m[32m    def read(self, n):[m
[32m+[m[32m        r = self.buf[self.offset : self.offset + n][m
[32m+[m[32m        if isarray(r):[m
[32m+[m[32m            r = tostring(r)[m
[32m+[m[32m        self.offset += n[m
[32m+[m[32m        return r[m
[32m+[m
[32m+[m
[32m+[m[32mclass Reader:[m
[32m+[m[32m    """[m
[32m+[m[32m    PNG decoder in pure Python.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, _guess=None, **kw):[m
[32m+[m[32m        """[m
[32m+[m[32m        Create a PNG decoder object.[m
[32m+[m
[32m+[m[32m        The constructor expects exactly one keyword argument. If you[m
[32m+[m[32m        supply a positional argument instead, it will guess the input[m
[32m+[m[32m        type. You can choose among the following keyword arguments:[m
[32m+[m
[32m+[m[32m        filename[m
[32m+[m[32m          Name of input file (a PNG file).[m
[32m+[m[32m        file[m
[32m+[m[32m          A file-like object (object with a read() method).[m
[32m+[m[32m        bytes[m
[32m+[m[32m          ``array`` or ``string`` with PNG data.[m
[32m+[m
[32m+[m[32m        """[m
[32m+[m[32m        if (_guess is not None and len(kw) != 0) or (_guess is None and len(kw) != 1):[m
[32m+[m[32m            raise TypeError("Reader() takes exactly 1 argument")[m
[32m+[m
[32m+[m[32m        # Will be the first 8 bytes, later on.  See validate_signature.[m
[32m+[m[32m        self.signature = None[m
[32m+[m[32m        self.transparent = None[m
[32m+[m[32m        # A pair of (len,type) if a chunk has been read but its data and[m
[32m+[m[32m        # checksum have not (in other words the file position is just[m
[32m+[m[32m        # past the 4 bytes that specify the chunk type).  See preamble[m
[32m+[m[32m        # method for how this is used.[m
[32m+[m[32m        self.atchunk = None[m
[32m+[m
[32m+[m[32m        if _guess is not None:[m
[32m+[m[32m            if isarray(_guess):[m
[32m+[m[32m                kw["bytes"] = _guess[m
[32m+[m[32m            elif isinstance(_guess, str):[m
[32m+[m[32m                kw["filename"] = _guess[m
[32m+[m[32m            elif isinstance(_guess, io.IOBase):[m
[32m+[m[32m                kw["file"] = _guess[m
[32m+[m
[32m+[m[32m        if "filename" in kw:[m
[32m+[m[32m            self.file = open(kw["filename"], "rb")[m
[32m+[m[32m        elif "file" in kw:[m
[32m+[m[32m            self.file = kw["file"][m
[32m+[m[32m        elif "bytes" in kw:[m
[32m+[m[32m            self.file = _readable(kw["bytes"])[m
[32m+[m[32m        else:[m
[32m+[m[32m            raise TypeError("expecting filename, file or bytes array")[m
[32m+[m
[32m+[m[32m    def chunk(self, seek=None):[m
[32m+[m[32m        """[m
[32m+[m[32m        Read the next PNG chunk from the input file; returns a[m
[32m+[m[32m        (*type*,*data*) tuple.  *type* is the chunk's type as a string[m
[32m+[m[32m        (all PNG chunk types are 4 characters long).  *data* is the[m
[32m+[m[32m        chunk's data content, as a string.[m
[32m+[m
[32m+[m[32m        If the optional `seek` argument is[m
[32m+[m[32m        specified then it will keep reading chunks until it either runs[m
[32m+[m[32m        out of file or finds the type specified by the argument.  Note[m
[32m+[m[32m        that in general the order of chunks in PNGs is unspecified, so[m
[32m+[m[32m        using `seek` can cause you to miss chunks.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        self.validate_signature()[m
[32m+[m
[32m+[m[32m        while True:[m
[32m+[m[32m            # http://www.w3.org/TR/PNG/#5Chunk-layout[m
[32m+[m[32m            if not self.atchunk:[m
[32m+[m[32m                self.atchunk = self.chunklentype()[m
[32m+[m[32m            length, type = self.atchunk[m
[32m+[m[32m            self.atchunk = None[m
[32m+[m[32m            data = self.file.read(length)[m
[32m+[m[32m            if len(data) != length:[m
[32m+[m[32m                raise ChunkError([m
[32m+[m[32m                    "Chunk %s too short for required %i octets." % (type, length)[m
[32m+[m[32m                )[m
[32m+[m[32m            checksum = self.file.read(4)[m
[32m+[m[32m            if len(checksum) != 4:[m
[32m+[m[32m                raise ValueError("Chunk %s too short for checksum.", checksum)[m
[32m+[m[32m            if seek and type != seek:[m
[32m+[m[32m                continue[m
[32m+[m[32m            verify = zlib.crc32(strtobytes(type))[m
[32m+[m[32m            verify = zlib.crc32(data, verify)[m
[32m+[m[32m            # Whether the output from zlib.crc32 is signed or not varies[m
[32m+[m[32m            # according to hideous implementation details, see[m
[32m+[m[32m            # http://bugs.python.org/issue1202 .[m
[32m+[m[32m            # We coerce it to be positive here (in a way which works on[m
[32m+[m[32m            # Python 2.3 and older).[m
[32m+[m[32m            verify &= 2**32 - 1[m
[32m+[m[32m            verify = struct.pack("!I", verify)[m
[32m+[m[32m            if checksum != verify:[m
[32m+[m[32m                # print(repr(checksum))[m
[32m+[m[32m                (a,) = struct.unpack("!I", checksum)[m
[32m+[m[32m                (b,) = struct.unpack("!I", verify)[m
[32m+[m[32m                raise ChunkError([m
[32m+[m[32m                    f"Checksum error in {type} chunk: 0x{a:08X} != 0x{b:08X}."[m
[32m+[m[32m                )[m
[32m+[m[32m            return type, data[m
[32m+[m
[32m+[m[32m    def chunks(self):[m
[32m+[m[32m        """Return an iterator that will yield each chunk as a[m
[32m+[m[32m        (*chunktype*, *content*) pair.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        while True:[m
[32m+[m[32m            t, v = self.chunk()[m
[32m+[m[32m            yield t, v[m
[32m+[m[32m            if t == "IEND":[m
[32m+[m[32m                break[m
[32m+[m
[32m+[m[32m    def undo_filter(self, filter_type, scanline, previous):[m
[32m+[m[32m        """Undo the filter for a scanline.  `scanline` is a sequence of[m
[32m+[m[32m        bytes that does not include the initial filter type byte.[m
[32m+[m[32m        `previous` is decoded previous scanline (for straightlaced[m
[32m+[m[32m        images this is the previous pixel row, but for interlaced[m
[32m+[m[32m        images, it is the previous scanline in the reduced image, which[m
[32m+[m[32m        in general is not the previous pixel row in the final image).[m
[32m+[m[32m        When there is no previous scanline (the first row of a[m
[32m+[m[32m        straightlaced image, or the first row in one of the passes in an[m
[32m+[m[32m        interlaced image), then this argument should be ``None``.[m
[32m+[m
[32m+[m[32m        The scanline will have the effects of filtering removed, and the[m
[32m+[m[32m        result will be returned as a fresh sequence of bytes.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # :todo: Would it be better to update scanline in place?[m
[32m+[m
[32m+[m[32m        # Create the result byte array.  It seems that the best way to[m
[32m+[m[32m        # create the array to be the right size is to copy from an[m
[32m+[m[32m        # existing sequence.  *sigh*[m
[32m+[m[32m        # If we fill the result with scanline, then this allows a[m
[32m+[m[32m        # micro-optimisation in the "null" and "sub" cases.[m
[32m+[m[32m        result = array("B", scanline)[m
[32m+[m
[32m+[m[32m        if filter_type == 0:[m
[32m+[m[32m            # And here, we _rely_ on filling the result with scanline,[m
[32m+[m[32m            # above.[m
[32m+[m[32m            return result[m
[32m+[m
[32m+[m[32m        if filter_type not in (1, 2, 3, 4):[m
[32m+[m[32m            raise FormatError([m
[32m+[m[32m                "Invalid PNG Filter Type."[m
[32m+[m[32m                "  See http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters ."[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        # Filter unit.  The stride from one pixel to the corresponding[m
[32m+[m[32m        # byte from the previous previous.  Normally this is the pixel[m
[32m+[m[32m        # size in bytes, but when this is smaller than 1, the previous[m
[32m+[m[32m        # byte is used instead.[m
[32m+[m[32m        fu = max(1, self.psize)[m
[32m+[m
[32m+[m[32m        # For the first line of a pass, synthesize a dummy previous[m
[32m+[m[32m        # line.  An alternative approach would be to observe that on the[m
[32m+[m[32m        # first line 'up' is the same as 'null', 'paeth' is the same[m
[32m+[m[32m        # as 'sub', with only 'average' requiring any special case.[m
[32m+[m[32m        if not previous:[m
[32m+[m[32m            previous = array("B", [0] * len(scanline))[m
[32m+[m
[32m+[m[32m        def sub():[m
[32m+[m[32m            """Undo sub filter."""[m
[32m+[m
[32m+[m[32m            ai = 0[m
[32m+[m[32m            # Loops starts at index fu.  Observe that the initial part[m
[32m+[m[32m            # of the result is already filled in correctly with[m
[32m+[m[32m            # scanline.[m
[32m+[m[32m            for i in range(fu, len(result)):[m
[32m+[m[32m                x = scanline[i][m
[32m+[m[32m                a = result[ai][m
[32m+[m[32m                result[i] = (x + a) & 0xFF[m
[32m+[m[32m                ai += 1[m
[32m+[m
[32m+[m[32m        def up():[m
[32m+[m[32m            """Undo up filter."""[m
[32m+[m[32m            for i in range(len(result)):  # pylint: disable=consider-using-enumerate[m
[32m+[m[32m                x = scanline[i][m
[32m+[m[32m                b = previous[i][m
[32m+[m[32m                result[i] = (x + b) & 0xFF[m
[32m+[m
[32m+[m[32m        def average():[m
[32m+[m[32m            """Undo average filter."""[m
[32m+[m
[32m+[m[32m            ai = -fu[m
[32m+[m[32m            for i in range(len(result)):  # pylint: disable=consider-using-enumerate[m
[32m+[m[32m                x = scanline[i][m
[32m+[m[32m                if ai < 0:[m
[32m+[m[32m                    a = 0[m
[32m+[m[32m                else:[m
[32m+[m[32m                    a = result[ai][m
[32m+[m[32m                b = previous[i][m
[32m+[m[32m                result[i] = (x + ((a + b) >> 1)) & 0xFF[m
[32m+[m[32m                ai += 1[m
[32m+[m
[32m+[m[32m        def paeth():[m
[32m+[m[32m            """Undo Paeth filter."""[m
[32m+[m
[32m+[m[32m            # Also used for ci.[m
[32m+[m[32m            ai = -fu[m
[32m+[m[32m            for i in range(len(result)):  # pylint: disable=consider-using-enumerate[m
[32m+[m[32m                x = scanline[i][m
[32m+[m[32m                if ai < 0:[m
[32m+[m[32m                    a = c = 0[m
[32m+[m[32m                else:[m
[32m+[m[32m                    a = result[ai][m
[32m+[m[32m                    c = previous[ai][m
[32m+[m[32m                b = previous[i][m
[32m+[m[32m                p = a + b - c[m
[32m+[m[32m                pa = abs(p - a)[m
[32m+[m[32m                pb = abs(p - b)[m
[32m+[m[32m                pc = abs(p - c)[m
[32m+[m[32m                if pa <= pb and pa <= pc:[m
[32m+[m[32m                    pr = a[m
[32m+[m[32m                elif pb <= pc:[m
[32m+[m[32m                    pr = b[m
[32m+[m[32m                else:[m
[32m+[m[32m                    pr = c[m
[32m+[m[32m                result[i] = (x + pr) & 0xFF[m
[32m+[m[32m                ai += 1[m
[32m+[m
[32m+[m[32m        # Call appropriate filter algorithm.  Note that 0 has already[m
[32m+[m[32m        # been dealt with.[m
[32m+[m[32m        (None, sub, up, average, paeth)[filter_type]()[m
[32m+[m[32m        return result[m
[32m+[m
[32m+[m[32m    def deinterlace(self, raw):[m
[32m+[m[32m        """[m
[32m+[m[32m        Read raw pixel data, undo filters, deinterlace, and flatten.[m
[32m+[m[32m        Return in flat row flat pixel format.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # print("Reading interlaced, w=%s, r=%s, planes=%s, bpp=%s"[m
[32m+[m[32m        # % (self.width, self.height, self.planes, self.bps, file=sys.stderr))[m
[32m+[m[32m        # Values per row (of the target image)[m
[32m+[m[32m        vpr = self.width * self.planes[m
[32m+[m
[32m+[m[32m        # Make a result array, and make it big enough.  Interleaving[m
[32m+[m[32m        # writes to the output array randomly (well, not quite), so the[m
[32m+[m[32m        # entire output array must be in memory.[m
[32m+[m[32m        fmt = "BH"[self.bitdepth > 8][m
[32m+[m[32m        a = array(fmt, [0] * vpr * self.height)[m
[32m+[m[32m        source_offset = 0[m
[32m+[m
[32m+[m[32m        for xstart, ystart, xstep, ystep in _adam7:[m
[32m+[m[32m            # print("Adam7: start=%s,%s step=%s,%s" % ([m
[32m+[m[32m            #     xstart, ystart, xstep, ystep, file=sys.stderr))[m
[32m+[m[32m            if xstart >= self.width:[m
[32m+[m[32m                continue[m
[32m+[m[32m            # The previous (reconstructed) scanline.  None at the[m
[32m+[m[32m            # beginning of a pass to indicate that there is no previous[m
[32m+[m[32m            # line.[m
[32m+[m[32m            recon = None[m
[32m+[m[32m            # Pixels per row (reduced pass image)[m
[32m+[m[32m            ppr = int(math.ceil((self.width - xstart) / float(xstep)))[m
[32m+[m[32m            # Row size in bytes for this pass.[m
[32m+[m[32m            row_size = int(math.ceil(self.psize * ppr))[m
[32m+[m[32m            for y in range(ystart, self.height, ystep):[m
[32m+[m[32m                filter_type = raw[source_offset][m
[32m+[m[32m                source_offset += 1[m
[32m+[m[32m                scanline = raw[source_offset : source_offset + row_size][m
[32m+[m[32m                source_offset += row_size[m
[32m+[m[32m                recon = self.undo_filter(filter_type, scanline, recon)[m
[32m+[m[32m                # Convert so that there is one element per pixel value[m
[32m+[m[32m                flat = self.serialtoflat(recon, ppr)[m
[32m+[m[32m                if xstep == 1:[m
[32m+[m[32m                    assert xstart == 0[m
[32m+[m[32m                    offset = y * vpr[m
[32m+[m[32m                    a[offset : offset + vpr] = flat[m
[32m+[m[32m                else:[m
[32m+[m[32m                    offset = y * vpr + xstart * self.planes[m
[32m+[m[32m                    end_offset = (y + 1) * vpr[m
[32m+[m[32m                    skip = self.planes * xstep[m
[32m+[m[32m                    for i in range(self.planes):[m
[32m+[m[32m                        a[offset + i : end_offset : skip] = flat[i :: self.planes][m
[32m+[m[32m        return a[m
[32m+[m
[32m+[m[32m    def iterboxed(self, rows):[m
[32m+[m[32m        """Iterator that yields each scanline in boxed row flat pixel[m
[32m+[m[32m        format.  `rows` should be an iterator that yields the bytes of[m
[32m+[m[32m        each row in turn.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        def asvalues(raw):[m
[32m+[m[32m            """Convert a row of raw bytes into a flat row.  Result may[m
[32m+[m[32m            or may not share with argument"""[m
[32m+[m
[32m+[m[32m            if self.bitdepth == 8:[m
[32m+[m[32m                return raw[m
[32m+[m[32m            if self.bitdepth == 16:[m
[32m+[m[32m                raw = tostring(raw)[m
[32m+[m[32m                return array("H", struct.unpack("!%dH" % (len(raw) // 2), raw))[m
[32m+[m[32m            assert self.bitdepth < 8[m
[32m+[m[32m            width = self.width[m
[32m+[m[32m            # Samples per byte[m
[32m+[m[32m            spb = 8 // self.bitdepth[m
[32m+[m[32m            out = array("B")[m
[32m+[m[32m            mask = 2**self.bitdepth - 1[m
[32m+[m[32m            shifts = map(self.bitdepth.__mul__, reversed(range(spb)))[m
[32m+[m[32m            for o in raw:[m
[32m+[m[32m                out.extend((mask & (o >> i) for i in shifts))[m
[32m+[m[32m            return out[:width][m
[32m+[m
[32m+[m[32m        return map(asvalues, rows)[m
[32m+[m
[32m+[m[32m    def serialtoflat(self, bytes, width=None):[m
[32m+[m[32m        """Convert serial format (byte stream) pixel data to flat row[m
[32m+[m[32m        flat pixel.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        if self.bitdepth == 8:[m
[32m+[m[32m            return bytes[m
[32m+[m[32m        if self.bitdepth == 16:[m
[32m+[m[32m            bytes = tostring(bytes)[m
[32m+[m[32m            return array("H", struct.unpack("!%dH" % (len(bytes) // 2), bytes))[m
[32m+[m[32m        assert self.bitdepth < 8[m
[32m+[m[32m        if width is None:[m
[32m+[m[32m            width = self.width[m
[32m+[m[32m        # Samples per byte[m
[32m+[m[32m        spb = 8 // self.bitdepth[m
[32m+[m[32m        out = array("B")[m
[32m+[m[32m        mask = 2**self.bitdepth - 1[m
[32m+[m[32m        shifts = map(self.bitdepth.__mul__, reversed(range(spb)))[m
[32m+[m[32m        l = width[m
[32m+[m[32m        for o in bytes:[m
[32m+[m[32m            out.extend([(mask & (o >> s)) for s in shifts][:l])[m
[32m+[m[32m            l -= spb[m
[32m+[m[32m            if l <= 0:[m
[32m+[m[32m                l = width[m
[32m+[m[32m        return out[m
[32m+[m
[32m+[m[32m    def iterstraight(self, raw):[m
[32m+[m[32m        """Iterator that undoes the effect of filtering, and yields each[m
[32m+[m[32m        row in serialised format (as a sequence of bytes).  Assumes input[m
[32m+[m[32m        is straightlaced.  `raw` should be an iterable that yields the[m
[32m+[m[32m        raw bytes in chunks of arbitrary size."""[m
[32m+[m
[32m+[m[32m        # length of row, in bytes[m
[32m+[m[32m        rb = self.row_bytes[m
[32m+[m[32m        a = array("B")[m
[32m+[m[32m        # The previous (reconstructed) scanline.  None indicates first[m
[32m+[m[32m        # line of image.[m
[32m+[m[32m        recon = None[m
[32m+[m[32m        for some in raw:[m
[32m+[m[32m            a.extend(some)[m
[32m+[m[32m            while len(a) >= rb + 1:[m
[32m+[m[32m                filter_type = a[0][m
[32m+[m[32m                scanline = a[1 : rb + 1][m
[32m+[m[32m                del a[: rb + 1][m
[32m+[m[32m                recon = self.undo_filter(filter_type, scanline, recon)[m
[32m+[m[32m                yield recon[m
[32m+[m[32m        if len(a) != 0:[m
[32m+[m[32m            # :file:format We get here with a file format error: when the[m
[32m+[m[32m            # available bytes (after decompressing) do not pack into exact[m
[32m+[m[32m            # rows.[m
[32m+[m[32m            raise FormatError("Wrong size for decompressed IDAT chunk.")[m
[32m+[m[32m        assert len(a) == 0[m
[32m+[m
[32m+[m[32m    def validate_signature(self):[m
[32m+[m[32m        """If signature (header) has not been read then read and[m
[32m+[m[32m        validate it; otherwise do nothing.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        if self.signature:[m
[32m+[m[32m            return[m
[32m+[m[32m        self.signature = self.file.read(8)[m
[32m+[m[32m        if self.signature != _signature:[m
[32m+[m[32m            raise FormatError("PNG file has invalid signature.")[m
[32m+[m
[32m+[m[32m    def preamble(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        Extract the image metadata by reading the initial part of the PNG[m
[32m+[m[32m        file up to the start of the ``IDAT`` chunk.  All the chunks that[m
[32m+[m[32m        precede the ``IDAT`` chunk are read and either processed for[m
[32m+[m[32m        metadata or discarded.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        self.validate_signature()[m
[32m+[m
[32m+[m[32m        while True:[m
[32m+[m[32m            if not self.atchunk:[m
[32m+[m[32m                self.atchunk = self.chunklentype()[m
[32m+[m[32m                if self.atchunk is None:[m
[32m+[m[32m                    raise FormatError("This PNG file has no IDAT chunks.")[m
[32m+[m[32m            if self.atchunk[1] == "IDAT":[m
[32m+[m[32m                return[m
[32m+[m[32m            self.process_chunk()[m
[32m+[m
[32m+[m[32m    def chunklentype(self):[m
[32m+[m[32m        """Reads just enough of the input to determine the next[m
[32m+[m[32m        chunk's length and type, returned as a (*length*, *type*) pair[m
[32m+[m[32m        where *type* is a string.  If there are no more chunks, ``None``[m
[32m+[m[32m        is returned.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        x = self.file.read(8)[m
[32m+[m[32m        if not x:[m
[32m+[m[32m            return None[m
[32m+[m[32m        if len(x) != 8:[m
[32m+[m[32m            raise FormatError("End of file whilst reading chunk length and type.")[m
[32m+[m[32m        length, type = struct.unpack("!I4s", x)[m
[32m+[m[32m        type = bytestostr(type)[m
[32m+[m[32m        if length > 2**31 - 1:[m
[32m+[m[32m            raise FormatError("Chunk %s is too large: %d." % (type, length))[m
[32m+[m[32m        return length, type[m
[32m+[m
[32m+[m[32m    def process_chunk(self):[m
[32m+[m[32m        """Process the next chunk and its data.  This only processes the[m
[32m+[m[32m        following chunk types, all others are ignored: ``IHDR``,[m
[32m+[m[32m        ``PLTE``, ``bKGD``, ``tRNS``, ``gAMA``, ``sBIT``.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        type, data = self.chunk()[m
[32m+[m[32m        if type == "IHDR":[m
[32m+[m[32m            # http://www.w3.org/TR/PNG/#11IHDR[m
[32m+[m[32m            if len(data) != 13:[m
[32m+[m[32m                raise FormatError("IHDR chunk has incorrect length.")[m
[32m+[m[32m            ([m
[32m+[m[32m                self.width,[m
[32m+[m[32m                self.height,[m
[32m+[m[32m                self.bitdepth,[m
[32m+[m[32m                self.color_type,[m
[32m+[m[32m                self.compression,[m
[32m+[m[32m                self.filter,[m
[32m+[m[32m                self.interlace,[m
[32m+[m[32m            ) = struct.unpack("!2I5B", data)[m
[32m+[m
[32m+[m[32m            # Check that the header specifies only valid combinations.[m
[32m+[m[32m            if self.bitdepth not in (1, 2, 4, 8, 16):[m
[32m+[m[32m                raise Error("invalid bit depth %d" % self.bitdepth)[m
[32m+[m[32m            if self.color_type not in (0, 2, 3, 4, 6):[m
[32m+[m[32m                raise Error("invalid colour type %d" % self.color_type)[m
[32m+[m[32m            # Check indexed (palettized) images have 8 or fewer bits[m
[32m+[m[32m            # per pixel; check only indexed or greyscale images have[m
[32m+[m[32m            # fewer than 8 bits per pixel.[m
[32m+[m[32m            if (self.color_type & 1 and self.bitdepth > 8) or ([m
[32m+[m[32m                self.bitdepth < 8 and self.color_type not in (0, 3)[m
[32m+[m[32m            ):[m
[32m+[m[32m                raise FormatError([m
[32m+[m[32m                    "Illegal combination of bit depth (%d)"[m
[32m+[m[32m                    " and colour type (%d)."[m
[32m+[m[32m                    " See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 ."[m
[32m+[m[32m                    % (self.bitdepth, self.color_type)[m
[32m+[m[32m                )[m
[32m+[m[32m            if self.compression != 0:[m
[32m+[m[32m                raise Error("unknown compression method %d" % self.compression)[m
[32m+[m[32m            if self.filter != 0:[m
[32m+[m[32m                raise FormatError([m
[32m+[m[32m                    "Unknown filter method %d,"[m
[32m+[m[32m                    " see http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters ."[m
[32m+[m[32m                    % self.filter[m
[32m+[m[32m                )[m
[32m+[m[32m            if self.interlace not in (0, 1):[m
[32m+[m[32m                raise FormatError([m
[32m+[m[32m                    "Unknown interlace method %d,"[m
[32m+[m[32m                    " see http://www.w3.org/TR/2003/REC-PNG-20031110/#8InterlaceMethods ."[m
[32m+[m[32m                    % self.interlace[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m            # Derived values[m
[32m+[m[32m            # http://www.w3.org/TR/PNG/#6Colour-values[m
[32m+[m[32m            colormap = bool(self.color_type & 1)[m
[32m+[m[32m            greyscale = not (self.color_type & 2)[m
[32m+[m[32m            alpha = bool(self.color_type & 4)[m
[32m+[m[32m            color_planes = (3, 1)[greyscale or colormap][m
[32m+[m[32m            planes = color_planes + alpha[m
[32m+[m
[32m+[m[32m            self.colormap = colormap[m
[32m+[m[32m            self.greyscale = greyscale[m
[32m+[m[32m            self.alpha = alpha[m
[32m+[m[32m            self.color_planes = color_planes[m
[32m+[m[32m            self.planes = planes[m
[32m+[m[32m            self.psize = float(self.bitdepth) / float(8) * planes[m
[32m+[m[32m            if int(self.psize) == self.psize:[m
[32m+[m[32m                self.psize = int(self.psize)[m
[32m+[m[32m            self.row_bytes = int(math.ceil(self.width * self.psize))[m
[32m+[m[32m            # Stores PLTE chunk if present, and is used to check[m
[32m+[m[32m            # chunk ordering constraints.[m
[32m+[m[32m            self.plte = None[m
[32m+[m[32m            # Stores tRNS chunk if present, and is used to check chunk[m
[32m+[m[32m            # ordering constraints.[m
[32m+[m[32m            self.trns = None[m
[32m+[m[32m            # Stores sbit chunk if present.[m
[32m+[m[32m            self.sbit = None[m
[32m+[m[32m        elif type == "PLTE":[m
[32m+[m[32m            # http://www.w3.org/TR/PNG/#11PLTE[m
[32m+[m[32m            if self.plte:[m
[32m+[m[32m                warnings.warn("Multiple PLTE chunks present.")[m
[32m+[m[32m            self.plte = data[m
[32m+[m[32m            if len(data) % 3 != 0:[m
[32m+[m[32m                raise FormatError("PLTE chunk's length should be a multiple of 3.")[m
[32m+[m[32m            if len(data) > (2**self.bitdepth) * 3:[m
[32m+[m[32m                raise FormatError("PLTE chunk is too long.")[m
[32m+[m[32m            if len(data) == 0:[m
[32m+[m[32m                raise FormatError("Empty PLTE is not allowed.")[m
[32m+[m[32m        elif type == "bKGD":[m
[32m+[m[32m            try:[m
[32m+[m[32m                if self.colormap:[m
[32m+[m[32m                    if not self.plte:[m
[32m+[m[32m                        warnings.warn("PLTE chunk is required before bKGD chunk.")[m
[32m+[m[32m                    self.background = struct.unpack("B", data)[m
[32m+[m[32m                else:[m
[32m+[m[32m                    self.background = struct.unpack("!%dH" % self.color_planes, data)[m
[32m+[m[32m            except struct.error:[m
[32m+[m[32m                raise FormatError("bKGD chunk has incorrect length.")[m
[32m+[m[32m        elif type == "tRNS":[m
[32m+[m[32m            # http://www.w3.org/TR/PNG/#11tRNS[m
[32m+[m[32m            self.trns = data[m
[32m+[m[32m            if self.colormap:[m
[32m+[m[32m                if not self.plte:[m
[32m+[m[32m                    warnings.warn("PLTE chunk is required before tRNS chunk.")[m
[32m+[m[32m                else:[m
[32m+[m[32m                    if len(data) > len(self.plte) / 3:[m
[32m+[m[32m                    